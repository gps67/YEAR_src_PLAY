2020-03-25_api_CACHE_SEGMENT_Layout

	_api_CACHE_ { ... } // confirm says CACHE api ...  // {
	_SEGMENT_Layout { Layout }
	}

	Layout += these_lines_of_TEXT_in_STREAM

		// stuff declared HERE // exists in DIAG
		// DIAG_SCRIPT_STATE += LOCAL_STACK_FRAME_VARS // via ENQ_ACK
		//  _ENQ_ _ACK_ _CACHE_ _API_

		STREAM += TEXT += LINES += LINE += MACRO_PARAMETISED_CODE

		MACRO_PARAMETISED_CODE += eG_TEXT_FLOW_STREAM_of_SCRIPT_LINES
		MACRO_PARAMETISED_CODE += eg_TEXT_of_SCRIPT_LINES

		STREAM += TEXT += LINES += LINE += SCRIPT_LINE += ARGV_ITEM
		// _t says ARGV_ITEM might be u32_lohi // u32_abcd

		// PSG_SUBLEX // {
			create a LEX TOKEN "//" AUTO_ALIAS " // " // TOKEN
			// basically create Object_t & item = EA_ITEM_EXPR
			// simply by mentioning it //
			// reName // bind SELF
			// lookup(" // ") MATCT _MATCHED_ 
			// PSG will be weaving CODE // CMNT ;# LINE_PARSER
			// PSG SCRIPT_LINE psg_parser
			// PHRASE SCRIPT_LINE_COMMENT_TO_EOLN 

				" STR0 "

			// PSG enters TEXT_ZONE CMNT_parser // UPTO_EOLN

			   UPTO_EOLN {
			   	// actually to ARGV_end or EOLN or "}" or ...
			   }
			   UPTO_EOLN {
			   	// another WORD [s] to send to "UPTO_EOLN"
			   }
			   UPTO_EOLN {
			   	// LINE ARGV INTERWEAVE
				FILTER PASS THROUGH TRANSPARENT // if ...

					ARGV_ITEM
					"a1a2star_plain_ascii_english"
					// "eg" "of" "is"
					// "adjective" "verb" "noun"
					/*
						a1_a2_star 

						 a1 += [A-Z]
						 a1 += [a-z]
						 a1 += [0-9]
						 a1 += [_] // ASIF_SPACE
						 a1 += [$] // PERCENT_VAR_SIGN
					 //	 a1 += [%] // %s 
					 // $VAR and %s rhyme resonate

					 	a2 += '%'
						a2 += CSET_from_TEXT(" %s ")
						// CSET_from_TEXT(" %s ") 
						// IGNORE SP1 not REQUIRED
						// SP1 not needed
						// SP1_FILTER_not_in_CSET
						// CSET _a2_ident
						// FILTER DROP ASIF noise
						// FILTER REMOVE_SP_from_CSET
						// FILTER ANYSTR_SP_into_CSET
						// FILTER LEX_EDGE SP_SEEN
						// FILTER LEX_EDGE LF_SEEN
						// FILTER LEX_EDGE EOF_SEEN
						// dont add " " to ident_CSET
						

					*/

			   }
			   UPTO_EOLN {
			   	WORDS for ARGV going through SUBLEX into PSG
				// eg " // " well_known_syntax_punctuation "
			   }
			   SUBLEX {
				// eg " . " well_known_syntax_punctuation "
				// eg " [ EXPR ]  " // SEQ is SUBLEX and PSG both
				// eg " . var_field_expr " // SEQ step in PSG
				// eg " -> var_field_expr " // adjust_USAGE
			   }
		}


	LOCAL -vs- REMOTE // rhume += MATCH OPCODE LHS RHS _t
	// _t is a LEX_HANDLER
	// _type_SPEC_ is CODE_POINT == "=="
	// _LHS_ // local
	// _RHS_ // remote
	//
	// _OPCODE_ _LHS_ _RHS_ _CMNT_ // ARGS # ( ... ) ;# CODE_POINT_dot
	// _OPCODE_SET_VAR_ EA_SELF = CODE_POINT_PLUS_DATA _DATA_
	//  _DATA_ // DIAG is LINE _TEXT_ /* utf8 */ /* u8_bit_clean */
	//  _DRAW_ _A_B_C_D_CACHE_ // += CTXT // // += CTXT.ARGS

		_CPU_
		_A_B_C_D_P_Q // ABCD_PQ // _SP_ _PC_ _CPU_

		_CPU_ = _CPU_t
		_PC_ Program Counter = CODE_POINT // auto_bind same_var
		_SP_ Stack_Pointer = DATA_FRAME // auto_bind same_stack_frame

		_A_
		_B_
		_C_
		_D_

		_P_
		_Q_

		_MMX_
		_CPU_
	
	THIS = SELF = CODE_POINT // eg CSR on FSM # SCRIPT_CODE_POINT

	THIS = SELF = SESS.VAR("anystr") // permit auto_bind_var_api
	THIS = DIAG.CODE_step // CODE_point // SCRIPT_LINE // cmd_line _DATA_
	THIS += TYPE.SPEC // SPEC_is_Module // _t
	THIS += TYPE.SPEC // SPEC_is_Struct // _t
	THIS += TYPE.SPEC // SPEC_is_Func // _t

	THIS += _ALIAS_ // of type SPEC_t // SELF += this // ... // _cmnt

	THIS += SCRIPT_LINE( ... ) {
	// _cmnt // { ... }

	 SCRIPT_LINE {
	 	array [ idx_t ] of ITEM_t
		ITEM_t idx_name = STR0 // 99% get lucky // TOKEN // 20% SPELLING
		ITEM_t = OBJECT_baseclass_t EG {
		} /* cmnt */ ... 
		... exists as a TOKEN // alias for CTXT += CTXT_SELF
	 }

		_OPCODE_

		  _CODE_ += DOT += OPCODE.HERE_CODE // AVAILABLE_EXPR [s]
		  _DATA_ += STO += OPCODE.field_DATA // SPEC_n_DATA_n_field_idx

		   _DATA_ += field_DATA // eg NBYTES P0P2 ...
		   _DATA_ += parser_for_DATA_ NEAR_CODE = SCRIPT_LINE

		   field_DATA = u32_payload via RPC_encoded

		   	LOCAL
				field_DATA
			REMOTE
				field_DATA
			API
				field_DATA
			HERE
				field_DATA // now with added UDEF_t
			ITEM
				u32_t // DIALECT

 ## // u32_t += Name_t_Name_v { ... } // "..." absorbs bit_field_layout ...
 ## { // ... // HEART_BEAT_SUBLEX_ref_to HERE
 // DIAG { ... } // ... means HERE these SCRIPT_LINES [s] prompted SUBLEX "%sS"
 // auto_PLURAL _LINE _LINES BIND_STREAM PARAMETER lookup("SCRIPT_TEXT")
 // auto_PLURAL_PSG LINES_OF_TEXT // each SCRIPT_LINE_TEXT

 	// Comment
	VAR_t VAR = EXPR" // explain += DIAG _FRAGMENTS_

	// PSG Alias PHRASE
	// VAR_t VAR = EXPR_t EXPR; // being in comment so not a repeat decl

	Name_t Type_Name_t; // EG "VAR_t"
	Name_t Var_Name_t; // ALIAS "VAR"

	// SUBLEX += "You can write any daft stuff in the comments"
	// STREAM += P0P2_or_BUFFER_or_NBYTES_or_PKT_as_DATA

	PSG += "VAR_t VAR" // = EXPR 
	PSG += "VAR_t VAR = EXPR" // explain += DIAG _FRAGMENTS_
	SCRIPT_ROM += _INIT_CODE_ // "SCRIPT._INIT_" // CODE_STEP_t // _FSM_

		SCRIPT ... += ARGV_ITEM [s]
		FRAME += ARGV_ITEM { Name Spelling _IDX_ Type 

	_SUBLEX_ _IDX_ can be replaced with _ITEM_ or _LIST_of_ITEM_
	_SUBLEX_ _IDX_ says transmit u32_idx u3_value
	_SUBLEX_ _IDX_ says KNOW u32_idx u3_value // u3 = bitfield_u3

 ## } // HEART_BEAT HERE too


 api_CACHE
 SEGMENT 
 Layout

 	secure model permits a rich vocabulary over some basic VAR SETTERS
	user's own system uses STRUCT_t and CODE_t upto QUOTA_t

		STRUCT_t & DATA = SESS.ALLOC.MMAP // idx_DATA = EA_DATA
		and
		CODE_t & CODE_point = CODE.ALLOC.IDX // CODE enum ... 
		upto
		QUOTA_t & QUOTA_PREDICTIONS = local_copy_of_remotes_guess
	
	fastest model permits LOCK allocation HERE subsequent PASS or FAIL or DELAY
	// DELAY can TIMEOUT achieving DELAY = dead_mans_handle_check_now

	fastest model = round_trip_time_ZERO // ASIF // ORIF // CHIP_RESOLVED

		ENQ -> what_is_value_of_expr("EXPR")
		ACK -> re_ENQ EXPR.VALUE = EXPR2 // almost DIRECT // u16 per EA

		ENQ += bunch of stuff to resolve later
		ACK += P0P2 of SEGMENT _in_STO _in_ROM _in_PKT 
		ACK += TOKEN that triggers CODE_FILTER_ACTION

			set SHARED("VAR") EVAL("EXPR")
			SHARED_VAR("VAR") // DECL_t // well_known_SPELLING
			SHARED_VAR("VAR") // DECL_t // well_known_ROLE
			SHARED_VAR("VAR") // DECL_t // well_known_SYNTAX
			SHARED_VAR("VAR") // DECL_t // well_known_VALUE
			SHARED_VAR("VAR") // DECL_t // well_known_CURR_USAGE
			// compile mode u32_payload
			// compile mode a2_is_cident_a2_PLUS // CSET_unravels
			set SHARED("VAR") EVAL( EXPR )

	LOCAL -vs- REMOTE // rhume += MATCH OPCODE LHS RHS _t
	CACHE
		LOCAL CACHE of REMOTE VAR
		// quota is quarter of MAX_SEGMENT then complain upto MAX
		// quota_prediction is STR0 Name = "SUBLEX OPCODE Name N_bytes"
		// quota_prediction avg_nbytes_20 // upto_total_quota // WARNS
		// quota_to_debug_with_200 // remains in u8_XPOS // REMIT
		// quota_multi_page_of_256_or_EXACT_PAGE_NBYTES
		// quota_to_debug_with_u32_stats // float N SUM_X SUM_XX
		// invalidate( FLOAT ) 
		// if( is_NAN( FLOAT )) ... KNOW_RECALC_NEEDED


		LOCAL VAR
		REMOTE CACHE of LOCAL VAR

			If REMOTE drops some CACHE, it can always ask again
			As REMOTE does what we ask, upto QUOTA
			we ask it to runs its CACHE of our LOCAL VAR
			it can be more generous (do pre-fetch pre-build)

		Our API notifies REMOTE immediately,
		but delayed by QUEUE of ENQ_ACK cycle and PRIORITY QUEUE
		DIFF might need full copy of EDIT history
		CACHE might be happy to see optimised set at end
		We can also set_NULL at_end, transmit NULL, invoke ROM
		PIPELINE QUEUES of UPDATES, SYNC_TO_EDGE, DONE,
		OPTION of architecture SPOOLED_QUEUED_TRANSACTION
		// with surprisingly few LOCK conflicts
		// almost as if work was already QUEUED
		// lots of self-contained pockets of DATA + EDITS
		// TRANSACTION touches HANDFUL of ITEMS
		// check all EDITS happened over unchanged terrain
		// PASS releasing locks, completeing TRANSACTION in JOURNAL

		LOCAL VAR
		REMOTE VAR
		REMOTE CACHE of LOCAL VAR

		REMOTE VAR
		LOCAL VAR
		LOCAL CACHE of REMOTE VAR

		SHARED BINDING
		CACHE gets told VAR=VALUE VAR.EDIT(...) CTOR DTOR COPY EDIT
		CACHE can be required to be AT_LEAST quota
		CACHE can be informed to use AT_BEST quota
		// eg transfer fonts onto 2GB graphics card
		// eg rewrite as BLIT_CITY

		UNTRUSTED REMOTE has a SCRIPT it wants running
		SCRIPT uses TRUSABLE PHRASES from local trustable ROM
		// still need to define bounds of TRUST // audit local ROM
		eg func(...) returns EA_EXPR which still has to be EVAL'd
		ie data(...) is TOKEN TOKENISED

