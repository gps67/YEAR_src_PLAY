	2023-06-13

	2023_06_Jun
	2023-06-13_MINI_MACHINE_ARGV.txt

	MINI_MACHINE
	ARGV_DECODER
	ARGS_TREE 
	ARGS_STR0
	ARGV_API // STR0 += SCRIPT_within_ARG_STR0
	ARGV_API // STR0 += SCRIPT_because_of_ARG_STR0 // GEN_to_INVOKE //

	OBJV is the target
	ITEM += TREE
	TREE += PHRASE
	PHRASE += LIST_of_ITEM
	PHRASE += SEQ ITEMS // BENCH opens VIEW to non parsed actions
	SCRIPT += SCRIPT_that_bench_prepared_earlier // STREAM of OPCODE 
	SCRIPT += STREAM_of_FRAGMENTS
	FRAGMENT += SCRIPT_STEP
	SCRIPT_STEP += DECL_ITEM
	SCRIPT_STEP += CODE_POINT
	SCRIPT_STEP += EVAL PHRASE '{ PARSED_PHRASE RT_VALUES RT VALS }'
	SCRIPT_STEP += EVAL PHRASE ' PARSED_PHRASE RT_VALUES RT VALS '
	SCRIPT_DECL += PARSED_PHRASE '{ RT_VALUES {RT VALS} }  }'
	SCRIPT_DECL += '{ RT_VALUES {RT VALS} }' // MATCH LOCAL MACRO
	SCRIPT_DECL += '{ RT VALS }' // MATCH LOCAL MACRO // NOTE_SP_USED_WAS
	LIBR_DECL += '{ VALS builtin_VAR_POOL_ _PLUS_ API }'
	API += "{ IDX = lookup( VAR_POOL SPELLING ) // CACHE += CACHE //"

	The point is to PARSE CXX and generate ARGV_TREE and respond to ARGV
	PARSE CXX and
	generate ARGV_TREE and
	EVAL ARGV // STEP ARGV // CALL EVAL ZONE // ZONE += ITEM

	The ARGV built is initially the CXX interperted
	The SESS usest is the CXX interperted
	The API usesd is the LIBR CXX PRE_GEN and compiled // DONE
	Seamless use of CXX VTBL // because it is CXX // which becomes C++ 

	ES99 is ES6 plus ASM_JS_stupid_int_markers plus WASM_SEGMENTS
	ES6 gets upgraded to ES99 which gets upgraded to "ES7_subset"
	ES_SUBSET == "ES99" ; ES99 == "JS_SUBSET_PLUS" // JSON_PLUS
	JSON_PLUS += GEN JS_SUBSET CXX to JS // required FILTER CXX subset
	CXX_SUBSET += FEATURE // PARSED GEN_JS API //






