2023-07-24_ID_G_prefix_X_plain_PLAIN_EXTRA.txt

	~/G/ 
	~/ABC/prefix/name/
	~/ABC/prefix/tinycc/lib
	~/G/prefix/tinycc/lib/tcc/include/tcclib.h

		a micro libc of printf and posix fopen dlopen
		you can easily go beyond the builtin into _most_any_lib
		but for those with no need for extra FILTER
		mini_libc work embedded with tinycc
		gen from CXX to GCC to TINYCC to ES6 // or ES7 // 

		USE dlopen to load SEGMENT_ELF 
			ELF += dlopen_libr
			ELF += dlopen STR0 // CAT FUNC ARG

		USE func_UDEF to intercept on_EVENT call FUNC_PROTO
			PROTO == PROTO_printf == %s( FMT, A, R, G, A )
			 FMT is printf_FMT // to the extent that tinycc does
			 FMT_limit_dialect_tinycc

	~/G/prefix/tinycc/lib/tcc/include/stddef.h

		#define
		 offsetof(type, field ) 
		  ((size_t)&((type *)0)->field)

		it EA(THIS) is 0
		then OFFS(THIS.field) == EA(THIS.FIELD) - EA(THIS) // ++ //
		// ++ // everything is ++ // field add BYES at XPOS == OFFS ++

	so

		tincc is a decent libc SUBSET
	

	tccdefs

		lots of local macros for "<string.h>"
		lots of local macros for "<posix_H>"

	tcclib.h
		decls for printf
		decls for dlopen // BASIC is plenty // FULL_API // C_MODULE



2022-09-09_ALIAS.ext // NEAR_LIST //
2022-09-08_119_mobile_G31.txt
2022-09-08_119_mobile_G31.pdf // ADJACENT MIME DOCUMENT DISPLAY_PANEL PAGES
2022-09-09_ALIAS.ext // PARSE CMNT as ARGS // NEAR ".ext" // AUTO_SUBST ".txt"

2023-07-24
	_ID_G_prefix_
	_X_plain
	_X_PLAIN_EXTRA.txt

		generic TEMPLATE for BENCH
		you provide your SCRIPT
		it compiles directly to LINKS '{ EXPR expr ARGS CMNT SESS }'
		it BINDS to each VAR_NAME there or SPEC_NAME or GUESS or_VAL

	 MATCH DATA

	 	MATCH '{ MATCH DATA }' // near names BIND into an API
		VAR_FUNC_MODULE_CAST_MACRO_IDEF // _API does it all

	PAGES == "STR0"
	 EG '{ PAGES == "STR0" }'
	 KNOW STR0 is VAR_NAME VAR_SPEC
	 # BENCH create "VAR_SPEC" as MENTIONED[%s]
	 # DIALECT IDX = lookup MENTIONED # STR0_t #
	 // DIALECT CXX // IDX_t IDX = lookup( str0 str ) //

	MENTION += KEY "%s" "KEY"
	# TOKENISED KEY == "KEY" // on_MATCH SCRIPT API //
	# API = "API" # a mentioned default spelling is { str0_t "VAR_NAME" }
	# typedef str0 str0_t ; // USAGE "VAR_NAME == "str0" AUTO_ADD_t("_t")
	# even the above function uses "OWN_NAME" and_Q2_USAGE('"str0"')
	# Q1_to_Q2 of ABOVE CALLER_MUST_PROVIDE_PRE_PARSED_Q2
	# Q1_to_Q2 of ABOVE CALLER_MUST_PROVIDE_PARSED_Q2
	# Q1_ _was_added_to_SIMPLE_Q1 # no_requote_needed_in_STR0
	# STR0_pass_through_ASIS # 
	# STR0 OUT = FILTER( IN ) # 
	# AUTO_DETECT Q3 PARSER recognises DIALECT and provides LIBR_LIFT
	# LIBR += MODULE_HERE # 
	# HERE += FILTER # ...
	# SESS += HERE ALSO MENTION LIST
	# AUTO "NAME" to ITEM pre-fetch
	# AUTO "MACRO" is ITEM_PREP // INIT_EXPR // ALIAS // DIALECT
	# BENCH # create VAR "MACRO" because it was MENTIONED
	# ALIAS MENTIONED MENTION
	# ALIAS MENTION OBJECT per SESS # API_OBJ #

		Most of a compile and AUTHORS work is DECL NAME SPEC CODE ALSO

		ONCE_DONE += DECL_VARS SEGMENT CFG STATE SESS CODE

		After that it is a lot of plumbing,
		connecting LHS to RHS via some SCRIPTED_MAZE
		eg CONVERT DIALECT LHS RHS // DATA_DIALECT
		eg CONVERT DIALECT RHS LHS // DATA_DIALECT

			IDX_t IDX = lookup STR0
			
		IDX_t IDX = lookup STR0

X_PLAIN.com
X_FANCY.com
X_Gtk_t X_Gtk = "{ INIT_CODE }" // or_INIT_by_VARNAME("VAR_NAME")
X_Gtk_t X_Gtk = "{ INIT_CODE }" // or_INIT_by_VARNAME("VAR_NAME")


	CACHE

		INIT_CODE == "%s"

		PARSE_PSG SCRIPT == "LOOKUP_NAME"

# AUTO #		VARS += BY_NAME("LOOKUP_NAME")
# AUTO #                             %s("LOOKUP_NAME")
# NEAR #		VARS += BY_NAME("%s") VAL == "VALUE"
# AUTO #		VARS += BY_NAME("VALUE") // CODE_POINT // MORE
# DATA # CODE_POINT += NEAR_NEXT_STMT_IN_SCRIPT_IN_SESS
# DATA # CODE_POINT += "{ SCRIPT }"
# DATA # CODE_POINT += "{ SCRIPT_LINE VAR_NAME = "VAR_VAL" }" // ANYSTR
# AUTO # ANYSTR via ALIAS SPELLING VAR_VAL SPELLING 
# MATCH # # AUTO # '%s("LOOKUP_NAME")' # Q1 += Q1_didnt_need_FILTER
# MATCH # NAME1 = lookup( SPELLING ) // NAME is ANYSTR // VIA_IDX_%04x
# DIALECT %04x" # USED in VIA_IDX_%04x # VIA_ALIAS "IDX_%04X" 
# DIALECT += "/* ANYSTR */ Q2 VAR_NAME _ %04X _AUTO_FMT_PICK
# _AUTO_FMT_PICK += ALIAS "04X" "alias_FFFF" "custom += "%04.4x" from GETTER
# CACHE # VARNAME("INIT_CODE") DATA("{ SCRIPT }") # CONNECT API VARS
# BENCH SCRIPT STEP with MAIN_ITEMS in SESS_STATE
# API VAR_NAME == "VAR_NAME" # Q2 VARANAME # MENTION_EXPR_PRE_GEN
# Q2 VARNAME # is a nearby explore GETTERS and SCRIPT to load cache
# COMPILE # GETTERS TEST DATA # AUTO_GEN_VAR_TYPE into_existance #
# X_PLAIN # from a clear SAMPLE in EXPLAIN as MODULE.CODE and OBSERVE EXPLAIN
# X_PLAIN # SEARCH list of alternate PATHS # _for_EACH_CODE PATH STEPS VARS2
# PSG_MAD # MATCH_ADDED_RILE RULE # MATCH == P0P2 XPOS and XPOS_STEP_NEXT
# REMOTE_REP uses_XPOS_STEP_NEXT == "{ XPOS_STEP_NEXT == "Q"_STR" }" 
# PSG_LEX "Q1_STR0_Q1" // NOTE have converted XPOS to STR0
# STR0 == XPOS ## and_therefore "_t"
# ROM CODE_POINT XPOS = PARSED XPOS += "{ XPOS STR0 P0_of_parsed_XPOS }"
# P2_of_parsed_XPOS # // PARSE from P0 to P2 to have CODE_POINT_KNOWS //

# BENCH += BEHAVIOUR

	on_VAR_NAME not known for OPCODE so "{ SCRIPT }"
	on_VAR_NAME not known for OPCODE so PARSED("{ SCRIPT }")
	TOKENISED += TOKENISER

		SPELLING += STR0
		ITEM_in_VIEW = TABLE_ITEM[ idx ] // MAYBE PTR or VAL or ...
	
	DIALECT add "..." as well known TOKENISED("...") // obvs LEX("...")



	SESS
	 VAR_POOL["%s"] # MENTIONED "STR0" # ALIAS ANYSTR CIDENT
	 NAME == lookup "SCRIPT" 
	 NAME == lookup "TEXT" 
	 NAME == "{ SCRIPT }" 
	 VALUE = VAR.VALUE() 
	 VALUE = "VAR.VALUE()" // CODE_POINT
	  NEAR ITEM is now in SCOPE so create a local REP of ITEM
	  REP = new ITEM_t ARGS CODE_POINT // PLUS //
	  REP = ITEM
	  ITEM == "ANYSTR" // short circuit ANYSTR // WORKS via lookup_idx
	  ITEM += PRE_COMPILE_D ANYSTR // NAME == "ANYSTR" // nbytes //
	  ITEM += NBYTES BYTES_in_STREAM
	  ITEM += P0P2 BYTES_in_STREAM
	  ITEM += XPOS BYTES_in_STREAM // POS in FILE // EA_EXPR_STEP

# EA_EXPR_STEP #
# EXPR_STEP #

	EA_EXPR_STEP == "EA_EXPR_STEP"

		# the universal create by MENTION == "MENTION"

			register STR0 in LEX_local 
			TOKENISER += STR0
			 // DIALECT // "TOKENISER += STR0" //
			 // BENCH GUI FIELD // AUTO_GUI_of_FIELD

			 	FIELD_TYPE += DECL_FEATURES

					ITEM. STR0_from_VALUE()
					ITEM. VALUE_from_STR0()


		# EXPR_STEP is a STEP_LEX in PSG #

			WE PRE PARSE SCRIPT 
			then RUN it

			so you could PRE_PARSE_SCRIPT
			and RUN it

		# '"{ LOCAL REMOTE }"' # DIALECT " LOCAL REMOTE "' # DIALECT 

			IDX_t idx = lookup STR0

		# ALIAS "%s" "{ IDX_t idx }" # 

GEN_CODE

	gcc has JIT worth using as API caller CODE WRITER

		CXX += MACROS SCRIPTS API_CALLER
	
	LLVM has LLVM_api // nothing like _py_api

		PY += DECL_ITEM ...
	
	SCRIPT declares CONCEPTS from simple CXX API

		OBJ. field
		OBJ. field_fn()
		OBJ. SETTER( NEWVAL )
		OBJ. GETTER( API ) // VALUE "VALUE" // VAR_NAME == "VALUE"

		OBJ. FUNCTION( ARGS ) // SESS.CTXT //
		OBJ. FUNCTION( ARGS ) // SESS.CTXT // NAMED_PHRASE_ACTIVE
		_COMPONENT
	
		SCRIPT. STEPS += STEP
		 STEP += LEX_STEP
		  LEX_STEP += STEP
		  LEX_STEP += Q2 CIDENT Q2
		  LEX_STEP += Q2 ANYSTR Q2
		  LEX_STEP += Q2 A_MATCH Q2 // MATCH_B also avail ...

		 /*
		 	CONSTRAINT CIDENT is usable lex_part in CIDENT
		 	CONSTRAINT CIDENT is usable lex_start in CIDENT
			CHECKER simply run FILTER which says OK_or_FAIL */
			FILTER += BUILTIN_CODE UDEF_SCRIPT GEN_CXX_GEN_SCRIPT
			SCRIPT += GEN_SCRIPT
			GEN_SCRIPT += gen_ARGV_or_C_ARGS_or_OBJV_ARGS
			BIND ROUTE DECL MATCH { CIDENT } { "%s" }

 LANG "%s" required Q2 to be as simple as '{ %s }' // BINDING added to BENCH
 CT_RT
 	BIND "{ KEY == 'IDENT' }" // LIBR += C_PRINT_API

		  LEX_STEP += PSG_LEX_PHRASE

		 */

		 STEP += LEX_STEP
		  LEX_STEP += Q2 CIDENT Q2



X_Gtk_t X_Gtk = "{ INIT_CODE }" // or_INIT_by_VARNAME("VAR_NAME")


RIDDLE

	cant a dog look up

	point a dogs spine upwards
	their head is point ing upwards
	now you - your eyes are forward
		when you look up 
		you see what the dog sees
		it is already looking upwards

		what does it mean for the dog to look up
	
	Clearly the dog can loohup, as much as us, or maybe less,
	but some, and snout prtects eyes, to eyeball up


