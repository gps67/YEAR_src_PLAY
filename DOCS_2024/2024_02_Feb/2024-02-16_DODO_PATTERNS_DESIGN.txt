	2024-02-16

	2024_02_Feb
	2024-02-16_DODO_PATTERNS_DESIGN.txt

 LOHI

 	WHY LOHI ?

		CPU picks one BYTE of u32_CPU_REGISTER

			it always picks the LOW byte_A
			at that LO pos it is first and ironically MOST signif

		PARSER can stop on 1 letter // KNOWN_BINARY_OPCODE

			BYTE PARSER NUMERIC TOKEN_READER

			u8 u16 u32 u64
			i8 i16 i32 i64 SIGNED
			i4_i4_u24 i4_i4 i8_OPCODE i8_EXPR i9_CODE_POINT

		CODE_POINT 

			EA_CODE_POINT "{ idx = N ++ }" " EA(idx) // CTOR_MAGIC

			EA("0xFF") ALIAS "0xFF" idx // or "idx" // EXTRA //

			IMPORT ALIAS idx

				declare something quite fundamental
				useful so export to GLOBAL-ify it
				CT_RT ALIAS through the MENTION
				// must be CIDENT97 // here ASCII_CORE

			DIALECT ALIAS CODE_POINT = idx

				PARSE " = " within ARGV ACCEPT "=" or OMIT

				BIND "idx" to SPELLING 

				GEN "if( idx == SPELLING ) ..."

				GEN "parses this TEXT" MATCH TEMPLATE ...

			CODE_POINT = "{ FILE OFFS }"

			FILE = "{ VAR_is_VFS_FILE }" // "%s // AVAT // TEXT
			FILE = VFS FILENAME FILEDATA MMAP_XPOS"
			XPOS = "{ FILE OFFS }"
			XPOS = "{ FILE LINE_NUMBER }"
			XPOS = "{ FILE LINE_NUMBER CPOS }"
			// CPOS is not BPOS becomes XPOS is N_GLYPHS 
			// CPOS is parse UTF9 // for now // Latin1 soon // PLUS
			// BPOS is byte_offs within line // Latin1 == CPOS
			// XPOS uses CPOS
			// OFFS is only one extra WORD //
			XPOS { u8_u8_u16 u8_FILE u8_CPOD u16_lno } // PICK lno
			XPOS { u8_u24 u8_FILE u24_OFFS } // PICK lno
			XPOS { u8_u24 u8_FILE i24_EXPR } // PICK " PLUS is IDX"
			XPOS { u32_ADDR } // MINI_MACHINE // u32_IDX // i32_IDX
		//	MATCH( ZERO ) // DECODE( NULL ) // GOOD OPTION M1 
			MATCH( ZERO ) // DECODE( PLUS ) // 
			MATCH( PLUS ) // DECODE( PLUS ) // 
			MATCH( MINUS ) // DECODE( MINUS ) // 
			MATCH( MINUS M1 M2 EOF CTRL ) // DECODE( CTRL ) // 
			MATCH M1 == "0xFF" // i32_from_i8 // i32_CPU_WORD 

			EXPR MATCH("XPOS u8_u24 XPOS") // CODE TYPE WORD
			TYPE BITFIELDS u8 u24_PAYLOAD 
			MACRO " i32_WORD >> 8 " // NOTE SP as ASM shorthand
			DIALECT " SP %s SP " "{ u24_PAYLOAD = i32_WORD >> 8 ; }"
			TYPE BITFIELDS u8 u24_PAYLOAD "u24_PAYLOAD = i32_WORD >> 8"

			STREAM = https://youtu.be/5ab7tIZNplM

			XPOS {
				FILE_in_VFS u8
					OPTION u8 EA_ITEM in MINI_MACHINE
					 EA_ITEM == "u8_lo"
					 EA_ITEM == "u8_A" 
					 EA_ITEM == "lo" 
					 EA_ITEM == "A" 

				// SEE	 EA_ITEM == "u8_hi" 
					 EA_ITEM == "u8_B" 
					 EA_ITEM == "hi" 
				// SEE	 EA_ITEM == "B" 

				FILE_in_VFS u8_u8

					OPTION u8_u8 EA_ITEM in MINI_MACHINE
					EA_ITEM is ROM_ITEM // SCRIPT
					ITEM_t item = GETTER_VECT[ u8_u8_idx ]

					DECODE(" u8_A u8_B ") // i16_LOHI //

				LINE_NUMBER u16

					i16_PAYLOAD = i32_WORD >> 16

					CREATE MACRO  " i32_WORD >> 16 "

						the excess SP pre_match GAP

				CPOS_in_LINE u8

					u8_CPOS = u32_CPU_WORD_BYTE_B // u8_hi
			}"

 LOHI

 	Any sensible CPU has excellent BITFIELD access and BYTEFIELD

	u32_LOHI
	u32_u32_PAIR LHS RHS // SAMPLE invoke line provides VAR_NAME == VALUE
	u32_LHS_lo
	u32_RHS_hi

		_lo appears at BYTE[0]
		_hi appears ar BYTE[4] BYTE_4567_as_i32 _as_u32 _u8_u24

			WORD_hi
			BYTE u8_lo
			i24 i24_
	
	BYTES are read like ASCII letters ABCD EFGH TEXT PARSE MATCH FILTER


 TEXT

 	ASCII left to right
	UTF8_TEXT NBYTES P0 N P2 // OBJECT present BOTH nbyeas and p0p2
	local ALIAS provides N P0 P2 // P0 Parser EOF_DETECT_API
	API_t N_P0_P0
	API_t u32_N ; u32 P0 ; u32 P2 ; ZERO "EA == P0" ALSO "CSR == P0"
	API_t u32_N ; u32 P0 ; ______ ; ZERO "EA == P0" ALSO "CSR == P0"
	API_t _____ ; u32 P0 ; u32 P2 ; ZERO "EA == P0" ALSO "CSR == P0"
	MERGE MATCH ABOVE LINES from TEXT STREAM

 TEXT STREAM

 	REPL or as if REPL via LIBR

	Grief Art CHERUB

 AUDIO STREAM

	STR0 URL = " url " // TEMPLTE // OPTIONS for DIALECT ALIAS SP_ONE
	https://music.youtube.com/watch?v=AgM9iv6Y0XI&si=UNxWz6i3jgdkKPRa

 REPL API

 	ENQ_ACK_REPL_API

	_ ENQ_ACK

	 	This API is tighly coupled with IP4_TRANSPORT_UDP 
		LHS -CONNECT- RHS
	_ HERE LHS RHS CODE_POINT

	_ REPL_API REPL API CODE_POINT // BIND_PARAMETER("CODE_POINT") // CT_RT

	_ _CT_RT CT_ _RT CODE_POINT //  BIND_PARAMETER("CODE_POINT") // CT_RT
	_ _ { SCRIPT }

 SCRIPT can apply SET to FILTER

 	PRINT TEXT PASTE TEXT PARSE_TEXT
	// contrain to CXX joins %s_%s when printing as single CIDENT

 CIDENT user defined CSET

 	a1 += PERMITTED_GLYPHS_in_a1 // [A-z] // [ a-z ] // [0-9] // GLYPH_LIST
 	a2 += PERMITTED_GLYPHS_in_a2 // a1 // that gets us its GLYPH_LIST via FILTER
	// FILTER over running CODE // running PARSED SCRIPT // TENSE //

 PARSED("SCRIPT")

 	if entire text is a recognisable 
	as CIDENT97 { cident99_a1_s2_star }

	AVAR "SCRIPT" // NAME or `lookup NAME` // UNIQUE SPELLING
	PARSE SCRIPT // FILTER notices that "VARNAME" was not in Q2 so AVAR
	AVAR "VARNAME" // BIND finds ALIAS SHIFT to EA_SPELLING"
	AVAR "VARNAME" // BIND finds CODE in SEGMENT and API
	AVAR "VARNAME" // BIND finds TEXT and PARSER finds CODE in SEGMENT

 PARSED("filename")

 	BIND remembers PICK of used EXPR and SESS.AVAR and ROM.AVAR
	LIBR API // bins to objects CALLABLES EXPRS // CT_RT

 REPL STREAMER

 	MUX provides a converyer belt of packets, eg LINES
	LINE Parsed from with FILE_UPTO_EOF // must use P2 and not need NUL



 ITEM includes EXTRA_CTRL_OPCODE

 	ITEM += CODE_POINT // repeat TERM used as search TERM SAMPLE_TWO
	CODE_POINT += 
	



