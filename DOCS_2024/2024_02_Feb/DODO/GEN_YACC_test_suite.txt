
REPEAT_PUBLISH_DOCUMENT # VFS += bison.info file and LIBR += bison.info 
# THIS iS ARGV SCRIPT # DIALECT more strict on ORIG_of_FILE # FILE_ORIGINS
# comment is often # CMNT # // is also avail as_are PSG_FILTER_RECOGNISES
# FILTER # TEXT # on_MATCH_call_API # FILTER SCRIPTS # SWEEPERS # FILTER HERE
# CODE_POINT has access to preloaded IMPORT LIST # FETCH_ALL _NOW # GETTER
# CT_RT _RT # GETTER # API # First use establishes MATCH SPELLING MK_ITEM
# CT_RT ITEM_t * ITEM = MODULES_TYPE_FOR_("ITEM_t") // ALIAS STR0 // PARSE
# that creates an DECL TYPE "{ ITEM_t ITEM }" // CMNT 
# CODE_POINT CMNT .TEXT = STR0 cident97 STR0_cident_2024 "%2
# VAR_NAME MATCH a1_a2_star # AUTO_BIND_VARS "{ a1 a2 star P0P1P2 }"
# P0P2 # P0 P2 # N = P2-P0 # P2 is_at nbytes_after_P0 # N_BYTES # API resolves
# P0P2_t # STO as "{ PAGE0 P0 N }" // "{ handwritten code }" //
# PICK "{ PAGE0 OFFS_P0 _N }" { SCRIPT HERE } // MATCH API builds DATA_ITEM "%s"
# CIDENT97 # a1_a2_star # AUTO PARSE THIS LINE a1 a2 star # GET_VAR_a1 _a2 GOT
# GOT a1_a2_star # LEX IDENT #
# PSG += LEX_cident_97 a1_a2_star # a1 a2 # XPOS of start of P0P2 # N unknown #
# PSG could parse STREAM buffer fragment #
# PSG using well known MATCH_a1_a2_star SCRIPT_COMPILED # call from ARGV
# CT_RT # CT_ _RT # LIBR # LIBR # GROUP LIBR # MODULE_PARSER_a1_a2_star #
# PSG uses an AXIOM BASE # simple words CSET Latin1 _in_utf8 CIDENT_a1_a2_star
# PSG uses an AXIOM BASE # simple words CSET Latin1 _in_utf8
# %s CIDENT a1_a2_star # CIDENT == "%s" as LEX_VAR_NAME STR0
# STR0 is XPOS in a flowing stream of buffer fragments # REPL line by line #
# ARGV is PARSE ARGV # PSG_LEX ARGV _t DIALECT SCRIPT TEXT TREE
# TREE += ARGV # ARGV += WORDS GAPS LOOKUPS TOKENISED_ARGV
# AUTO_LEX "TOKENISED_ARGV" TOKENISED_ARG TOKENISED _ARG # COMPILER # CT_RT #
# on_MATCH "VAR_NAME" # // TRY "STR0" as VAR_NAME in DIALECT #
# AUTO IMPORT "VAR_NAME" "STR0" ANYSTR # SELF_THIS_ALIAS # ASIF_third_person
# AUTO MK_VAR  AVAR "VAR_NAME" # thats the name of the VAR VAR_NAME
# and the VAR of that ANYSTR # %s # IDENT # EA # ITEM # NAME # STR0
# STR0 is %s # GEN STR0 = "STR0" # Welcome to VAR_NAME is EA_as_STR0_IDENT
# STR0_Ident "DIALECT" %s #
# STR0 is expected to PARSE TEXT STREAM REPL LIST CACHE # REQUIRE NUL somewhere
# STR0 is expected to stop before SEGMENT_P2 # CT_RT _RT += CHECK_P2
# CHECK_ran_PSG_over_TEXT_and_found_TEXT_TREE LINES WORDS INDENTED_BLOCKS
# INDENT CODE_LINE LIST XPOS # COMPILED_ROM # XPOS == CODE_POINT #
# MINI_MACHINE "{ CMP XPOS CODE_POINT }" # creates a LOCN with STO FILE_OFFS
# XPOS # u8 * P1 = XPOS # GETTER P1 = P0 # CT_RT #
# XPOS # u8 * P1 = XPOS # GETTER P0 = PAGE0 + OFFS_P0 # CT_RT #
# XPOS # u8 * P1 = XPOS # GETTER P0 = PAGE0 + OFFS_P0 + OFFS_P1 # CT_RT #
# u8 * CSR = PTR = P1 # PAGE0 # EA_within_PAGES # PAGE2_P2 # BOUNDS_CHECK #
# ROM SESS calls CODE with DATA and CODE_POINT XPOS #
# XPOS = CODE_POINT = OFFS_in_TEXT_FILE FILE = VFS_XPOS STO ITEM RUN CODE
# KNOW FILE == FILE_ONE # feature "{ item += feature }" # PARSE ARGV #
# KNOW FILE == FILE_TWO # sample city #
# KNOW FILE == FILE_LIBR # XPOS += "{ LIBR FILE OFFS XPOS }"
# KNOW FILE == FILE_LIBR # XPOS += "{ LIBR FILE LINO CSET XPOS }"
# CSET is "{ CSET_ _Latin1 _utf8 _cset }" # Latin1 # _cset == UDEF # CT_RT #
# CSET LEX ident ident_obj # obj = lookup_ident ident # UNARY use of "ident"
# ALIAS "obj" MK_VAR in SCOPE #
#


  TODO 
	bison .info 

		samples

			adjusted to VFS TEXT GEN


				RUN ORIG with test data
	
		samples

			GEN .y from PSG SCRIPT

				RUN PSG with BATCH
				RUN PSG with REPL

				REPL bundles TASKS to SCRIPTS

				 RUN LINES in LIST
				 RUN LINE of ARGV 
				 IT_SAYS "%s"
				 IT_ASKS GETTER VAR_EXPR CT_RT_SPEC CT_SPEC

		helps build up vocabulary 
		LEXICON
		ITEMS_LIST
		TEXT_TREE Module # NEBULOUS OUTER SHELL AUTO API #
		AUTO_API MODULE = TREE_BRANCH _XPOS LIBR FILE LINO CPOS
		CPOS is the CHAR POS or GLYPH count in line [0[N

 DIALECT P0P2
 DIALECT [0[N

 	Code can convert between P0P2 and "[0[N" // STR0 == "[0[N"

		HIJACK ALIAS "STR0" with WELL_KNOWN VALUE "[0[N"
	
	"[0[N"

		-- that says it was found as STR0 that continues afterwards
		-- that is a LEX promise -- LEX stays in P0P2 and "[0[N"
	
	u24 N 

		-- you can store references upto 16 MB
		-- you cant store references beyond 16 MB
	
	u32 N
		-- ARM32 machine prefers a 32BIT filesize 4G 
		-- MINI_MACHINE does not need above u16 IDX and u16 EXPR
		-- CPU32_in_CPU64 -- CPU gets u32_WORD in u64_AVAR
		-- CPU's can read u32_WORD from u32_u32_PAIR
		-- CPU's can run "u32_WORD = * PTR"
	
	PICK u32 as LIMIT N_ITEM IDX_N

		API for ITEM in LIST { SCRIPT }

		 AUTO SCRIPT is PARSED SCRIPT
		 AUTO for ITEM in LIST ACTION

		Basically all our modules fit in u24
		so a database LIMIT of u32_idx for ROM CODE and DATA is OK

		it is a FSM a MINI_MACHINE running STEPS in REPL 
		it might use the builtin LIBR of scripts -- OPTIMISED
		they might be TRUSTED or just FAST -- BOUND_CHECKING_ALWAYS
	
 DIALECT P0P2
 DIALECT [0[N
 
 	BOUNDS_CHECK N fits in u24_N 
 	OPTION_ACTION set ARG from u12 from EXPR // half of u24 // u4_u4 //
 	OPTION_ACTION set ARG from u32 from EXPR // u24_idx %s //  u32_idx //
 	OPTION_ACTION set ARG from u48 from EXPR // u48_ARCHITECTURE
 	OPTION_ACTION set ARG from i64 from EXPR //
	GEN_CODE "{ idx = u24_idx }"
		GEN_CODE "{
			u24_idx = "u24_idx" // BIND u24 BIND idx //
			idx = u24_idx // BIND as ASSIGN // GETTER // MID_VAL
			// BYTE_A = CPU_REGISTER_WORD_from_BYTE _SIGN_OPTS
			// CPU_STEP_WORD_from_BITFIELD // or BYTE_FIELD //
			// u24_PAYLOAD = u32_WORD >> 8 // BYTE_A // " u8 u24 "
			// MID_VAL i32 = u24_PAYLOAD
		}"
	fits in u24_N 
	the SIGN EXTEND is a formalisation of MK_VAR from VALUE
	a new VAR COPY is created # detect RO preferred #
	GEN_CODE "{ pool = u12_pool }"
	GEN_CODE "{ idx = u12_idx }"

	A MINI machine can still organise a HUGE DATA SET
	with a CPU and SCRIPT that fits in u12 # FSM # u8_u12_u12 # u4_u4 _#
	a bit like GREP can PICK each line from STREAM no LIMIT 
	almost u8 was usually u8_u8_OPCODE // BITFIELD "u8_u8_u16_u32"
	almost u8 was usually u8_u8_u16_u32 is next

	// no GEN_CODE "{ OPCODE = u8_OPCODE }" // CT_RT //

	
	u48 N
		-- u48_LIMIT _u48_ARCHIITECTURE
		-- u8_u8_OPCODE u48_PAYLOAD

		u48_PAYLOAD = u32_WORD >> 16 // read MACRO from GEN 

		DECODE "{ BYTE_A BYTE_B u48_PAYLOAD u64_WORD }" // += _LOHI

	MENTION "u8_u8_OPCODE"

		AUTO SUBLEX JOIN_SUBLEX "_%s" u8 lhs u8 rhs 
		AUTO SUBLEX JOIN_SUBLEX "_%s" OPCODE THIS_PAIR_of_BYTES
		AUTO SUBLEX JOIN_SUBLEX "_%s" OPCODE THIS_PAIR_of_BYTES u48


	 get_N
		N = u48_PAYLOAD

	get_OPCODE = "{ decode STR0 }" 
