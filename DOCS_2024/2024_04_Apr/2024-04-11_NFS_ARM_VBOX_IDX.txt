2024-04-11_NFS_ARM_VBOX_IDX.txt

 IDX

 	IDX is a genre as a bunch of related CT_RT IDX
	CT_RT provides "IDX" technology as a MODULE for DIALECT ITEM EA
	CT_RT IDX_t & IDX = AVAR idx_of_NOUN_TWO // a few names _ONE _TWO _NOUN
	IDX += cident eg u6_IDX_xFF // VITFIELD
	IDX += cident eg u8_IDX_xFF // BYTE // BYTE_FIELD BYTE_B // CT_RT i64
	// CT_RT BIT_FIELD
	IDX += cident eg u16_IDX_xFFFF // %s_xFFFF // SAMPLE_VALUE xFFFF
	// x prefix makes it cident99 compattible when "%04X" 
	// because "x%04X" is cident99 complient // USES "x" HEXDIGIT //
	// '{ VALUE "x%04X" }' // LAYER of Q1 over Q2 // AVOID // FOCUSED USAGE //
	// "{ VALUE x%04X }" // OMIT LAYER of Q1 under Q2 // "x%04X" 
	// DIAG VIEW Q2 %s Q2 with FG_BG_Q2 = FG_BG_PUNCT // YAWN // EMIT // OMIT
	// DECL // EMIT // FADE // OMIT // DEDUCE decl from NEARBY MENTION ROM
	// ROM // Module provides VAR_POOLS full of DECL and STO in SESS
	// ROM // CT_RT can upgrade TABLE from ROM to RAM // second WASM layer
	// FILTER JS6 "OBJ.FUNC(A,R,G,S)" // AUTO KNOW VAR("RET_VAL")
	// LEX == STR0 # cident97 # 

 cident97 is a LOCAL DIALECT 

 	mostly
		a1_a_star
		a1
		a2
		DOCS
	WRAP MODULE SCRIPT

		expect_WRAP_is_DECL_AVAR _in_action("STEP")

		decode "STEP" - it is mentioned in ROM SOURCE
		it is available in the RAM REPLACE SOURCE REWRITE PROVIDE SCRIPT
		RAM REPLACE CODE SCRIPT
		SCRIPT.META has info on how to attach SCRIPT as ITEM or as SCRIPT
		ie SCRIPT held in MINI_MACHINE EXPR is ITEM in CACHE # on_LOAD()

		CT_RT on_LOAD // GEN compile CT_RT HERE // CT_RT LOADED_STO
		// CT_RT loaded SCRIPT // { NAME %s } // { SCRIPT_NAME NAME } //
		// { FN A R G S } // += import as part of UDEF_LIBR
		// { FN A R G S } // += import as part of SESS in CACHE

	SAFE ANYSTR

		The risk of ANYSTR is absurd,

		but it can also be eliminated completely,
		by rewriting ANYSTR = IDX_from_EA "{ EA STR0 }"
		IDX_from_EA "{ EA STR0 }" {
			MATCH_ABOVE_HEADER ... // BIND VARS
			REMOTE runs ANYSTR through its own TOKENISER
			REMOTE benefits from DIALECT over its own SCRIPTS
			REMOTE compiles with TOKENISE
			REMOTE renames ANYSTR to " x%04F " // NOTICE LEX_EDGE
			REMOTE renames ANYSTR to "x%04F" // GUESS_not_LEX_EDGE
			// DECL += NAME_PART // used in "%s_%s_%s" etc
			// LIBR includes a small list, as used in SCRIPTS
			// LIBR CACHED FILTER GEN_all_in_RANGE in SCRIPTS
			// += %s_%s_%s // intentionally OMIT Q2 // VIA GUESS //
			"{ %s _ x %04X" }" {
				this ARGV of STEPS "{
					%s {
						TABLE_NAME_in_EA_NAME
						TABLE_NAME_in_EA_DATA
					}
					_ { 
						JOIN "{ LHS _ RHS }"
						JOIN "{ %s _ %s }"
						JOIN "{ %s }" THEN "{ _ %s }"
	START = CSR_looking_at_a_cident97 // AVAR_xFFFF // SAMPLE DATA M1 //
	START = LHS = %s = cident97_LHS // incl a1_start a1
	STEP = RHS = %s = cident97_LHS // incl a2 // or more complex // PARSE //
	BECAUSE this cident is used in "UDEF_AVAR_FFFF" alias "xFFFF" 
	BECAUSE this step in PARSE cident97 is JOINER("_")
	// JOINER("_") //

					}
	STEPS += STEP
	STEP += OMIT "x" because LHS is present else EMIT "x"
	STEP += EMIT "x" because LHS is NULL and cident97 needs a1 a1_plus x"
	a1_plus is RE a1_plus a1 
	a1_plus is RE a1_star a1 --but_plus
	PARSE "{ [ LO <= VAL < [ HI }"
	PARSE "{ [ P0 <= VAL < [ p2 }"
	PARSE "{ [  0 <= VAL < [ N }" //
	PARSE "{ [  1 <= VAL < [ N }" // is_PLUS
	PARSE "{ [  0 == VAL < [ N }" // is_ZERO
	PARSE "{ [  0 <  VAL < [ N }" // is_PLUS
	N = "N_chars_in_LHS" --must_be_at_least_1
	N = "N_chars_in_LHS" --may_be_ZERO
	N = "N_chars_in_LHS" --may_be_ZERO_as_PLUS_as_IDX

	DIALECT use "x%04F" as ALIAS for "%s_%04X"
	DIALECT parses matches caches FMT "%s%s%s" "%s_%s" and list used in ROM
	DIALECT adds a few AUTO_GEN as BACKGROUND on PRE_LOAD of MACROS USED
	COMPILER gets benefit of PHRASE which DIALECT did not actually use
	COMPILER gets AUTO_GEN BACKGROUND 
	COMPILER gets AUTO_GEN_PARSER
					x
	DIALECT uses "%04X" as ANYSTR for IDX_ITEM_IDENT_AS_u16_idx
	DIALECT uses "%04X" as ANYSTR for u24_IDX u16_IDX u12_IDX
	"u12_IDX" is upto when the fourth HEX digit is USED
	"u12_IDX" is "%03X" "FFF" u12_FFF // or sample value
	"u8_IDX" is "%02X" "FF" u8_FF // or sample value // "0F"
	"xFF" is ALIAS for above // u8_idx //
	"u4_IDX" is "%X" "F" u4_F // or sample value
	"%04X" "{ [IDX] [ 0000 ... FFFF [ XS }" "[IDX]" " [ GAP IDX GAP ] "
	NAFF parser rules permit confusing "[" with [
	NAFF parser upgrades to "[" with "{ VIEW_AS [ }"
	NAFF parser upgrades to "[" with "{ VIEW_AS 'Q2[Q2' }"

					%04X
	
	ARGV of STEPS includes WRAP STEPS "{ Q2 L_BRACE }" // AUTO_LEX_EDGE_GAP
	ARGV of STEPS includes WRAP STEPS OPTIONAL "SP" or "GAP" or NO_GAP
	GAP += OPT_GAP CT_RT can presume GAP is what VIEW wants and ignore
	GAP0 += no STO not needed PARSED out DIFFERENT or EXACT_MATCH ABSENT
	GAP0 += no STO not needed PARSED out DIFFERENT or EXACT_MATCH SP_ONE
	GAP0 += no STO not needed PARSED out DIFFERENT or LOOSE_MATCH GAPS
	ARGV of STEPS includes WRAP STEPS "{ R_BRACE Q2 }" // AUTO_LEX_EDGE_GAP
	
				}" 
			}

		}

	IDX_FFFF {
		replace "IDX" with "%s" // Q2 sanity helps PARSER + KDB
		replace "IDX" with "%s" // "IDX" is "ITEM_POOL_NAME"
		replace "FFFF" with "%04X" // "IDX_t idx = /* ALLOC */ N ++ ;
		VAR_POOL_TABLE_N -is- N is IDX_P2 IDX_XS IDX_HI_XS IDX_TOP
		TABLE_ITEM_idx_t idx = /*ALLOC*/ TABLE_ITEM_idx_N ++;

		VALUE of "FFFF" is "u48_SIX VALUE"
		VALUE of "VALUE" is "{ i64 VAL }" // TEMP var for VIEW cache 
		COPY of VALUE is LOCAL CACHE from REMOTE claiming PARSABLE
		PARSE eg within LEX or ANYSTR of from CSR_in_STR0
		PARSE "TAG_FFFF" as "%s_%04X" TAG IDX // HINT u16
	}

