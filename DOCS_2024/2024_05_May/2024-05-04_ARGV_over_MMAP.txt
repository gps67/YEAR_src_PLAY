	2024-05-04

	2024_05_May
	2024-05-04_ARGV_over_MMAP.txt

	MMAP
	HEAP
	ZONE
	ARGV
	 CSR

	SESS
	.SESS_VAR("AVAR") // promote LEX by USAGE as "AVAR"
	// AVAR becomes %s
	// AVAR is the SCOPE UNIQUE_NAME_STR0 "AVAR"
	// AVAR.BENCH CT_RT MENTION XPOS INTENTION EXPLAINS
	// EXPLAIN 
	// AVAR becomes %s
	// In this script wherever you see the VAL "AVAR" as CIDEN99
	// as CSET_EXPR_NOUN_ // _unique_SPELLING // resonance means MATCH
	// exact SPELLING used in SCRIPT // BENCH helps maintain tidy lists
	// exact XPOS "{ LIBR FILE XPOS OFFS XPOS LINE XPOS "{ LINE XPOS }"
	// ALIAS XPOX XPOS_t // VIEW += _t TOKENISED_PRECISE PARSED_APPROX
	// XPOS_t APPROX_XPOS = "STR0" //
	// CT_RT MECAHANISM // KNOW this is compiled EXPR CODE of SCRIPT XPOS
	// CT_RT SESS CT_ _RT CT_RT_in_MODE CT_RT_as_MODE "{ idx = N ++ }"
	// an ARGV of SCRIPT expressed as a Q2_STR0_Q2 // PSG drops RHS Q2
	// PSG DROP Q2 enables CT_RT SESS to do it's COMPILER FILTER ACTION
	// GEN Q2_LBRACE_SP_HERE_SP_RBRACE_Q2 // 
	// GEN actually lets LOCAL CACHE for REMOTE ASKING_ENQ
	// 
	// GEN Q2_LBRACE_SP_HERE_SP_RBRACE_Q2 // 
	// GEN
	// Q2_LBRACE_SP_HERE_SP_RBRACE_Q2 // 
	// yyQ2 LBRACE SP HERE SP RBRACE Q2 // ARGV from STR0 // CACHED // CT_RT
	// FILTER detects use of CT_RT as ARGV_ZERO // CMD_OPCODE_EXPR_STR0
	// 
	// Q2		# PSG_STEP_PUNCT("Q2") // my local dialect defines Q2
	// LBRACE	# LBRACE set to "{"
	// SP		# DETECT_EXACT_PARSED_GAP_LEX_EDGE
	// HERE		# replace "HERE" with %s # DATA_STEP_in_PSG_WORLD
	// SP		# GEN is EXACT # PARSE is PSG with Layout ie_GEN_CXX
	// RBRAC	# RBRACE set to ")"E
	// Q2		# _PUNCT("Q2") # _PUNCT has proper PSG avail ARGV MMAP
	// // 

	SESS.MMAP 
	.MMAP 

	MMAP HEAP ZONE ARGV CSR

		MMAP - provides nbytes and MEDIA_LABEL_found_in_INDEXED
		HEAP - provides ALLOC IDX NBYTES OFFS EA_EXPR
		ZONE - CALLER_PROVIDES - that's YOU saving your nbytes to DB
		ARGV - EA_EXPR within ZONE_LIST
		 CSR - XPOS in SCRIPT in SESS at CLOCK_WHEN
	
	MMAP - nbytes MEDIA_LABEL_found_in_INDEXED
		
		MMAP 
		nbytes
		MEDIA_LABEL_found_in_INDEXED

			MEDIA
			LABEL
			_found_in_ lowercase_fades_to_background_UPPER_AVR
			INDEXED

	MEDIA_LABEL

		LABEL_11_BYTES_of_ASCII_PLUS // _PLUS is 8-bit-transparent
		CSET_UTF8 usually 
		CSET_BYTE
		CSET_BYTE_Latin1
		CSET_BYTE_Nascom1 _8859_with_added_glyphs_over_HI32 etc
		CSET UTF8_FONT we use Latin1 codes for what LIBR provides GLYPHS

		META
			LABEL_11 - ABOVE
			DATE CREATE PRE_DATE might be attr in META_HEAD
			META_TYPE is NBYTES_FILENAME

				N_BYTES += "{ N BYTES }"

				N { STORED REPEATED in META }
				N { P0P2_as_N  // in_META }

		DATA is a FILE, MMAP loaded RO_RW

			ROM_CODE
			.text
			ROM_DATA
			.text
			.bss
			.text
			ROM_DATA_
			STO_DATA

 see how this works
 we invoke an idea by naming it
 we get lucky and that name gets parsed by our BIASED parser tp ARGV TEMPLATE
"{ N BYTES }" // AUTO // N // BYTES // FSM STATES{ PLANNED PRESENT BOTH }
That idea can be "WELL_KNOWN"
"{ idx = N ++ }" // "{ DIALECT }" // "{ ARGV }" // STEP("idx") STEP("=")
// STEP_GAP // PARSER has done exact parse of STR0


		DATA is MEDIA is an MMAP_of_HEAP

			MMAP is the outermost FILE NBYTES wrapper
			MMAP can also be a BACKING_FILE_SESS_MMAP
			MMAP can also be a BACKING_FILE_USER_MMAP

		FILE is a HEAP with added file prefix header

			FILE_HEADER_64_bytes
			FILE_HEAP_4K_upto_u16x4K u64x4K ==
			HEAP u64_x_4K is_256_M
			HEAP 8_x u24 is_128_M
			OFFS 1_x u24 is_16_M // LIMIT BYTE_OFFS else u48 or u32

		FILE is often a single HEAP
		FILE is often a HUGE FILE of many HEAPS

			OPCODES available for UDEF
			TABLED_BENCHED(u8_in_shared_space)

			 u2_11
			 u2_10
			 u2_01
			 u2_00

			 _MINUS M1
			 _ZERO 
			 _ONE
			 _TWO

			 _MINUS M2
			 _MINUS M1
			 _ZERO 
			 _ONE

			 _MINUS M3
			 _MINUS M2
			 _MINUS M1
			 _ZERO 

			 BASE_CLASS_i2 : CODE_POINT_picks_i2_in_i3_frame

				EG a WINDOW of 4 items 
				ON a LAYOUT of u16 items

				CLASS PICK "[-32K[+32K"
				CLASS PICK "[-64K[0
				CLASS PICK "[-64K[0[1 // 0_is_PLUS 1_is_OUT

					clearly -64K would have to lose 1
					(a) it does
					(b) it does not BUGS happen on_FULL

			 BOVE_CLASS_i2 N_SLOTS = TOTAL_ADDRS = array_N = (N - M)
			 BASE_CLASS_i1 [M1[0[N // N == 1 "{ -1 0 }" is_PLUS(0)

			 _MINUS M1
			 _ZERO 

			 u2_PAYLOAD = HIGH - LOW // can exceed u2 // not BITSHIFT
			 u2_PAYLOAD = ITEM - ZERO // generic ARRAY rule

			 MINI_MACHINE prepares u8_u2_PAYLOAD 

			u3_100  u8_104 OVER // P2 is P0 of NEXT so outside
			 u2_11	u8_103 // not named in P0P2 world // MINUS M1 
			 u2_10	u8_102 // not so MINUS M2 // USED as PLUS_TWO
			 u2_01	u8_101 // PLUS_ONE // +1
			 u2_00	u8_100 // PLUS_ZERO // LOW // P0

		HEAPS_of_PAGES

			the outer file heap manages big files
			each segment is complete 4K pages

			outer WRAP container

				Has own HEAPS in top level shared with group
				has HUGE storage BAYS which are aligned
				has HOLE in first PAGE stolen by HEADER

			each SEGMENT

				loadable from elf_api RO or RW
				resolve on_load and bind all ENQ_ACK

				MMAP segment , possibly with ITEM_ZERO is META
			
				L M Z N R

				Between [L - [M is where FILE_HEADER is

				ITEM_ZERO is still AVAILABLE
				ITEM_idx = ITEM_ZERO + ITEM_number






			
	



