	2024-05-14

	2024_05_May
	2024-05-14_dot_dot_dot_dot_PEER_DIR.txt

	so the initial though with this file, is to require HUNCH ../../%s/
	then those are themselves stepping stones ...

	OPTION %s -> %s
		LHS += A_FILE_in_ADIR // well known filename // from ADIR
		RHS += A_ROUTE_to_ADIR // GEN ARGV ls -s RHS/LHS LHS
		// GEN ARGV // GEN OBJV of TREE_ITEM_TOOL_EDIT_ARGV EDIT_ARGV
		// _EDIT _ARGV // _EDIT is the CODE_POINT SCRIPT // _ARGV is
		// _EDIT is _LOCN at VFS_DIR_NEAR_BENCH_VAR_POOL
		// _ARGV is _AVAR in LOCN

	VFS 
	 CACHE("%s") is_a_filename
	 TAGS("%s") is_a_filename_component in DIAG
	 TAG used in EXPR used in _filename 
	 VFS switches when TAGS change 
	 VFS LIST += ITEM // repeat name is not a SPELLING // IDX //
	 VFS LIST += ITEM // unique name within list used for LOOKUP

	2024-05-14_dot_dot_dot_dot_PEER_DIR.txt
	^	2024-05-14
	_	dot_dot
	_	dot_dot
	_	PEER_DIR
	.	.txt
	$	_LEX_EDGE

	PICK OPTION instead of ../../ADIR/filename
	PICK OPTION instead of ../ADIR/filename
	PICK OPTION instead of ./ADIR/filename
	PICK OPTION instead of ./BDIR/ADIR/filename
	PICK OPTION instead of ./EXPR/ADIR/filename

		BDIR = EXPR // generally not .. but could be how it was

			DETECT ".." 
			ALLOW because .. is not outside UDEF
			ALLOW because .. is BIND_LINK_TO  outside UDEF

			DETECT "ANYSTR"
			ALLOW but with added CIDENT99_prefered
			ALLOW but with added CIDENT97_adds_utf8_latin1
			ALLOW but with added CIDENT97_adds_BYTE_latin1
			ALLOW_PUNCT_in_FILENAME // never in CIDENT99
			TEACH_PUNCT_TO_SPELL // or _FFFF lookup_IDX
			TEACH_PUNCT_TO_SPELL // AND_OR_COMMA_SEMICOLON_ETC
			TEACH_PUNCT_TO_SPELL // _%02X_ // merge _outside_
	


	

eg in G_PHOTOS I need a BENCH pointer to ADIR_on_BENCH

	pwd
	/home/gps/G_PHOTOS/tmp_DCIM_GC/Camera/Thu_16

	ln -s ../rename_IMG/

 readlink _rename_IMG.tcl 

	./rename_IMG.tcl -ln-s-->
	./rename_IMG/rename_IMG.tcl // most obvious
	../rename_IMG/rename_IMG.tcl // imported peer UNCLE_ADIR FILE_NAME ARGS ...
	// ARGS has a list of possible TEMPLATES // OPT UDEF runs RULES_UDEF
	// ARGV has been upgraded to OBJV
	// STR0 has a CIDENT99 strictness about it
	// STR0 has a IDENT strictness that uses VAR_NAME_TABLE for VAR_POOL
	// VAR_POOL has lookup STR0 OBJ OBJV LIBR_API_for_VAR_POOL_PLUS _PLUS
	// ... mention _VAR_POOL _PLUS 
	// ... within MULTI_PART_WORD _JOINED _SPLIT _explain _label _samples
	// ... CT_RT VIEW pick _SAMPLES_PICK = PUSH _samples("%s") = "%s"
	// ... "{ %s %s }" _KEY _OBJ // "%s" introduces own PSG_TECH_nology
	// OBJ = lookup( KEY ) // C and JS syntax // OPTION ARGV SYNTAX //
	// OPTION ARGV SYNTAX //
	// OPTION ARGV SPEC // ALIAS SPEC SYNTAX // LEX_MELD associate MIX_MATCH
	// MIX_MATCH EXACT_MATCH MIX_MATCH MIS_MATCH // flaw in PIXEL flag
	// LEX_MIX SPEC SYNTAX
	//
	// as well as PSG_PHRASE_mentions_CIDENT99

		link already uses .. for ADIR_bench_local_via_LINK

			that is a local LINK to a specific place on the BENCH

			using a BENCH to correctly phrase LINK ROUTE NAMES
	
		link route uses ./LINK_TO_ADIR/known_file_on_that_BENCH

			this treats NEARBY as IMPLEMENTATION_ROUTE

				optimiser can PICK and SWITCH CT_RT between modes
				optimiser manually set to a fixed profile 

				profile == config of BENCH

	// VIEW built over PSG STEPS used in SPEC of ITEM

 // BENCH OVER TASK += CONNECT_MOBILE MOVE_CARGO_ALONG

 //	// TASK // 	move files to archive 

 	track GIT ITEMS = NBITES as a FILE with NAME and _META ALIAS _HEAD
	rename putting YEAR_MM_DD into filename // GEN_PARSE_badly_drawn_varname
	dialect template FILTER over template

		rename FIELD
		multiply ITEM as ARRAY[PICK] of ITEM with ARGS
		eg rename AVAR into _VAR_ONE
		eg rename AVAR_two into _VAR_TWO
		AVAR.SPEC += BASED_on_PROTOTYPE
		PROTOTYPE.AVAR.SPEC += BASED_on_PROTOTYPE
		OBJ = PROTOTYPE
		OBJ += C_PTR_EA 
		SPEC += struct
		struct += A_FIELD
		struct += A_FIELD
		struct += A_FIELD
		struct += A_BASE_PROTOTYPE
		struct += A_BASE_ITEM_TYPE // eg JS_OBJ += struct("%s")
		struct += A_FIELD "%s" /* STR0 = "STR0" */ "{ AUTO_VAR_NAME }"
		struct += A_FIELD "%s" /* STR0 */ "{ SPEC SPEC }" "{ INIT EXPR }"
	
	// BENCH creates a TASK // TASK is load photos from DCIM to NFS

		// RCP XFER NBYTES FILE NAME LOCN _PLUS 
	
	// BENCH creates one of its rich pre-loaded LIBE of tools + UDEF

		// UDEF += some_temp_filenames_in_dir // DROP_DATA FILTER //
		// UDEF += some_KEEP_files_in_dir // well known files or ..
		// UDEF += rename_FILE_with_FIELDS // and a few rogue SUBLEX //
		// UDEF += some SCRIPT phrases and man page highlighters
		// UDEF += item_in_VAR_POOL locally known as AVAR // _CURR_
		// PSG += NOUNS PHRASES USAGE USED TOKEN SPELLING
		// 
	
	// BENCH AUTO regenerates VIEW from basic STYLE and STEPS

		// mention AVAR as { "%s" SPELLING }
		// NB Q2 already used in sample so PICK
		// OPTION '{ %s }'
		// OPTION  { %s }  // no Q1 // use TCL_CURLIES_as_Q1 // NEAR
		// OPTION "{ %s }" // Q2 BQ "\\" // tame awful papercut zone
		// OPTION FILTER Q2 is matched in SCRIPT_EDIT // 

	// BENCH GROW DIALECT //

		// shelves and hooks and tables and places and items placed locn
		// LOCN ITEM // CODE_POINT is DECL or new in SCRIPT
		// CACHE_over_EA can ADD_FIELDS // unused when all PRE_SET

	// API _get("%s") _lookup() // ARGS explained later // strict loose 

		When we are using CACHE we get an immediate idx for OBJ_PLUS

		OBJ.idx.OBJ_PLUS += "SCRIPT_OBJECT_FFFF"

			every attached item must have a list of attribues

			ATTR NAME // OPTIONAL is AVAR[0] is AVAR
			ATTR SPEC // NOTE_WHEN_DATA_ARRIVES_WITH_STRANGE_SPEC
			ATTR_SPEC // _FFFF is EA_ITEM_ATTR
			ATTR_ADDR // _FFFF is EA_ITEM_ATTR

			SCRIPT knows ... so can bring those INIT_VALS along





	



	





