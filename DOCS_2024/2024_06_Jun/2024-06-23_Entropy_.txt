	2024-06-23

	2024_06_Jun
	2024-06-23_Entropy_.txt

VIDEO by 
COMEDY THOUGHTFUL COLD
Entropy_	// PARSE += CAP1 _of_NOUN _of_PROPER_NOUN 
Entropy_	// PARSE += %s // CIDENT_97 == SESS.LOCAL.AVAR.signal += ARGS
Entropy_	// PARSE += TRAILING_underline //
Entropy_	// LEX_EDGE _mid_lex_EDGE_ZONE // LEX_END // PICK

		// ANSWERS on a POSTCARD // CALLED and URL // TBS //

NAMESPACE { SCRIPT } {

	TEXT
	HERE
}


	Entropy is the thing that will do us in
	Enacted by this comedian: (TBS) URL 
	// the TEMPLATES used in a DIARY of TASK_LIST
	// DIARY AUTO ADDS mtime // filter mtime to READ_PERMS BIND_PERMS
	// ENABLE using PERMIT // and LOGIN or BATCH //
	// USER can schedule on_EVENT // FILTER ACTION BIND_DATA SESS
	// SESS on_EVENT_xFFFF // simply track the current N in HEAP
	// AUTO_GROW BITFIELD _8 _16 _32 _64
	// AUTO_GROW BITFIELD _8 _16 _32 _64 _48 
	// AUTO_GROW BITFIELD _8 _16 _32 _64 _48 UDEF
	// AUTO ROLL SCRIPT PLAY on_EVENT in BENCH

		NBITS grows earlier than it needs to, by half

			IE it demands i16 to hold i12
			IE it demands i16 to hold i8 // when 8 were fine

				This is because of N does not fit in NBITS
				This is because of N is 1 more than 
				can be said in NBITS
				must fit in NBITS 
				it_IS("NBITS")

				eg u4_idx PICK_u4_idx // get own name // RULZ

				F is 15 in binary is ---0-1111

					immediately TAG SPELLING
					as SPELLING_USED_ELSEWHERE
					ie DOUBLE CLAIM on AVAR _NAME

					Then this "F" gives up it's claim
					It is for CALLER to provide PICK_LIST

				N is 16 in binary is ---1-0000

				F is 15 in binary is ---0-1111
				E is 15 in binary is ---0-1111
				D is 15 in binary is ---0-1111
				C is 15 in binary is ---0-1111

				Z is 00 in binary is ---0-0000

	LEX_MATCH_END_LEX

		END_LEX

			PARSE STREAM of LEX ITEMS in SCRIPTS

				set LEX_NAME "END_LEX"
				set LEX_SPEC  LEX_NAME { SCRIPT }
				set LEX_STEP GOTO call_exception

			GOTO with local vars set correctly

				a way of calling with ARGS and CTXT and

		LEX_IDENT

			DIALECT uses "cident_97" 
			USED_in VFS_DIR_NAMES
			ALONG_WITH "." ".." PUNCT_in_NAME // as_NAME

			CT_RT says VAR_POOL["LEX_IDENT"] // sample value name
			AVAR = lookup_AVAR_by_STR0 STR0
			STR0 = "LEX_IDENT" // not yet SPELLING PTR

 How would you know, what is delivered is a PTR to STR0
 CONST means PTR_to_ROM
 There is a reasonably quick lookup, and we might preplace "LEX_IDENT"

 OPTION: u64_ITEM_EXPR // WORD in long line of WORDS //
 OPTION: u64_DECODED u8_u8_u16_u8_u24
 OPTION: u16_DECODED u12_u4
 OPTION: u16_DECODED u4_u12 

 	u16_DOZEN_HEAPS_of_4096_ITEMS

		u12_4096 // technically needs u13 // and first to do so //
		u13_4096 // EXPECT GROW uses i16 then i32 then i64 // u32
	
	MINI_MACHINE has a

		HEAP_of_ITEMS UPTO_4096 then on_OVER -aka- OVER_UPTO_OVER
		HEAP_of_CODE PAGES_of_4096

			EIGHT_t EIGHT[4096]

			EIGHT_t EIGHT_RET_VAL = READ_WORD_PAIR
	
 +-- u2 -- PICK_KEYWORD
 |	| u2 { ... }	// PICK_LIST[4] // AUTO_GROW u3_PLUS
 |	|	0	READ_WORD
 |	|	1	READ_WORD_PAIR
 |	|	2	READ_WORD_TUPLO
 |	|	3	READ_WORD_LIST
 |	| u3 { ... }	// PICK_LIST[8] // AUTO_GROW u4_PLUS
 |	|	4	READ_WORD_PARSE
 |	|	5	READ_WORD_GEN
 |	|	6	READ_WORD_RUN
 |	|	7	READ_WORD_VIEW
 |	| u4 { ... }	// PICK_LIST[%d] // AUTO_GROW u%d_PLUS // ...

 	MINI_MACHINE has [u4] MINI_MACHINE_HEAPS of_4096_ITEMS

		eg LOAD_LIBRARY_TEN // plenty several //
	
	MINI_MACHINE uses OPCODES with ARGS from BITFIELDS in the OPCODES

		OPCODE += u4_PICK _FROM_LIST_of_a_DOZEN // 
		OPCODE += u4_HEAP _FROM_LIST_of_a_DOZEN // _of_HEAP
		OPCODE += u12_ITEM _TABLE_of_4096_PTRS // of_EIGHT // _ITEM

		reusing EIGHT code may confuse WHICH is being DECODED
		that is the point of a SCRIPTED BENCH CT_RT ARRAY_of_EIGHT



	
	LEX_ITEM

		NOUN
		NAME

			ITEM SPEC DECL LEX "NOUN"
			NOUN SPEC DECL LEX "NOUN" // NOUN_idx == NOUN //

				import AVAR("NOUN") from API

				STR0 == "NOUN"
				ALEX == "NAME"
				SPEC == SPEC_UDEF { SCRIPT }
				on_EVENT( XPOS, CODE_POINT, ARGV
				CODE_POINT = CALLERS_API.CODE_POINT

				CT_RT creates a path through DIALECT
				CT_ DESIGN

			ITEM SPEC DECL LEX "NOUN"

		DATA

			SPEC says DECL SCRIPT
			SPEC says DATA SCRIPT eg XML with SCHEMA
			SPEC says CALL SCRIPT eg STO with API // _GETTER

			LINK_to_ITEM

				ITEM_t & item = EXPR; // CMNT

		KNOW
		TOKEN

			MATCH("SPELLING")
			MATCH("ANYSTR")
			MATCH("CIDEN99") // cident_97 _98 _99 _00 _01

		EG
			Entropy_

			LEX KNOW CAP1
			LEX KNOW trailing "_"
			LEX KNOW leading "_"
			LEX KNOW mid "_"
			LEX KNOW leading mid /* SAME _ */ _ == "_"

				AVAR called "_"





