	2024-08-22

	2024_08_Aug
	2024-08-22_fabric_of_DIAG_includes_EDIT_TEXT.txt

	TUPLO("ITEM.SPEC") // trim all PUNCT keep CT_KNOW_CODE_POINT

		CODE_POINT is any of many things

		A_FUNCTION_NAME
		A_VAR_NAME

		CODE_POINT is merged ASIF multidimentional

			this works because the func_names and data_names
			are unique within SCOPE_TREE_of_CSR

		SCOPE_TREE_of_CSR

			are unique within
		// ALIAS ITEM = MK ITEM //
		// XPOS_TREE ITEM // ARGS // CTXT // API // LIBR // PLUS
		// SCRIPT sees above ARGV as PARSED ARGV "//" is a valid WORD
		// WORD_WRAP // WORD identifies as TEXT_UTF8 and MIME_INFO
		// XPOS_TREE // XPOS // ITEM // ARGS // CTXT // API // LIBR // PLUS
		// XPOS_TREE XPOS ITEM ARGS CTXT API LIBR // PLUS 
		// That "//" above becomes a HARD_STOP on the MACRO FINAL_ANSWER
		// The "PLUS" after that can optionally be dropped
		// untested best not but tested BECOMES API WITH WITHOUT
		// SECURE SWITCH // PLUS is for you not for OS
		// SWERVE_OMIT // PLUS is available INSIDE with SCRIPTED UDEF
		// MMAP_AREA // MINI_MACHINE does not lack LIBR("UDEF")
		// MMAP_AREA // MINI_MACHINE does not lack LIBR("ANYSTR") // as_
		// MMAP_AREA // STO_one == STO.STO_one
		// MMAP_AREA // STO_two == STO.STO_two
		// MMAP_AREA // STO_ZERO == STO.STO_ZERO
		// MMAP_AREA // STO_FULL == STO.STO_FULL // or nearest_M1 //
		// ENUM_LIST // MINUS_ZERO_PLUS _ENUM _ITEM _ABSENT _OTHER _NUMERIC 
		// ENUM_LIST_PICK // CSR in ENUM_LIST attached to idx_PICK
		// ENUM_LIST // PRE_LOAD_SEGMENT BASE_CLASS_of_u5_enum_ITEM
		// LIST_PICK // OPCODE EXPR "{ ITEM_t * ITEM[u5_idx_CSR] }"
		// "{ ITEM_t * ITEM = ITEM[u5_idx_CSR] }" // A_BITFIELD_AVAR
		// "{ ITEM_t * ITEM = get_ITEM(u5_idx_CSR) }" // A_FUNC
		// "{ ITEM_t * ITEM = ITEM[u5_idx_CSR] }"
		// "{ ITEM_t * ITEM = ITEM(u5_idx_CSR) }" // NOT_VALID_C
		// FIX ask_for "get_ITEM(u5_idx_CSR)" // EXACT MATCH in LIBR
		// ALIAS "SPELLING" // LIBR_asks_for_permit_to_COPY_ALIAS_CALLS
		// so LIBR calls LIBR then calls UDEF then ...
		// so HERE lives same list of experiences
		// useful for LOCAL mimicing REMOTE
		// we both claim to be using the same API, same SCRIPT_TEXT
		// REMOTE might never run anything, thats up to REMOTE
		// RUNNING REMOTE CT_RT // local CACHE

		CACHE of VAR_LIST

			LOCAL
			REMOTE

			LEFT
			RIGHT
			[MID]

			my_ref
			your_ref

				my_ref = DECL AVAR VAR_NAME
				your_ref == VAR_NAME 

			ITEM + "{ TOKEN SPELLING INFO }"

				CT_INFO
				RT_INTO

				CT_RT INFO ITEM EXPR LEAF ITEM TREE

				CT
				RT
				SPELLING
				STR0
				%s
				Q2

				WEAVE += PSG

				Q2 is a CALLABLE_FILTER_LAYER
				Q2 is a FILTER_LAYER for ITEM PROCESSING

					it recognises C Q2 parsing
					it recognises ES6 parsing of Q2_str
					it guesses STR_UTF8 from SESS_CSET_one
					it guesses P0P2 from PARSE_P0
					// LEX_Q2_PARSER can deliver Q2

				Q2_DIALECT_CXX just like C but via DECODER

					printf "%04X" idx_ITEM // asif u12_idx
					printf "%02X" idx_ITEM // asif u8_idx

					printf "%02X" idx_ITEM //
					printf "_%02X" idx_ITEM // CIDENT99_OK

				printf_DECODER

					place a TEMPLATE over AVAR as API_plus
					place a TEMPLATE over AVAR as CACHE_API_

					We want some FILTERABILTY action
					We want some printf_CALLED_session

					CTOR {
					//	setup the new_INST_of_SPEC
					//	GEN will list its _DECLS _VARS
					//	we use our parameters INIT_VAL
					//	INIT_ZERO
					//	INIT_DATA _DATA
					//	INIT_FUNC _FUNC _ARGS 
					//	NEAR_POS2
					//	FROM_POS2
					//	INTO_POS2
					//	API offers SCRIPTABLE on_CALL
					//	API tries not to get OVER_LOAD
					//	API plenty fast on NET_BOOK
					//	_and_SCREEN24 // at_HOME at_WORK
					//	SESS is available as a GLOBAL
					//	

					}
					DTOR {
					}

					API_asks_for_JIT_for_CODE_POINT
					API_asks_for_SCRIPT_around_CODE_POINT

						EA is THIS TREE WHEN SITE LIBR 

						EA_XPOS _in_TREE

	// FAKE ADVERT // require_extra		EA_XPOS _in_TREE
	// TAKE OBJECT // EA_XPOS_

					API_ask_for_CODE_POINT_of_DECL_of("%s")

					("XPOS")
					("TREE_XPOS")
					("EA_XPOS_in_TREE") // EA XPOS TREE
					// ok so simplistic VAR finder
					// MENTION "XPOS" // on_MENTION_IDENT
					// CIDENT99_utf8_latin_PLUS
					// FILTER detects use of UTF8_latin_DECODER
					// CSR is at XPOS on SCRIPT
					// CSR has VAR_POOL from SCRIPT
					// CSR has VAR_NAME_DECODER SCRIPT
					// return EA_XPOS_in_TEXT
	FABRIC of TEXT 
	FILTER_of_FABRIC of TEXT 
	FILTER_of_TEXT 

		u32_u32_TOKEN // EA_as_ZONE_FILE_HEAP_ITEM_FIELD_EXPR_ _AVAL
		u32_u32_TOKEN_AVAL // 
		u32_u32_VALUE_TOKEN // 
		u32_u32_VALUE_TOKEN_from_EXPR // FILTER lower UPPER MENTION 
		// a few false positives, but once CT_RT has tokenised
		// the unused (yet) remain uncalled // until activation day

		u32_u32_STATE
		
			DECODE_u32_u32_STATE( 
				u32_u32_STATE // 
			)
	
	(ABOVE) a bunch of switchable implementations of above are available

	(ABOVE) callers do not have to make sense, picasso art under Q2 WRAP
	(ABOVE) callers do have to make sense, EXPR decodes as TEMPLATE_INST

		u8_u8	OPCODE

		u16() // means A_FUNC that returns an u16 of following name
		u16() u16_PAYLOAD // ALIAS _u16

	speculatively,
		COMPILER prepares BUNCH of GEN_CODE_for_EXPR
		If uncalled GEN_CODE occupies LIBR ROM space
		If called GEN_CODE code that after being RUN can GEN_CODE _DATA
		
		Multiple runs, that log all steps, call all SCRIPTS,
		PREP_PRE_LOAD

		HALF of the OPCODES from u32_one wanr ARGS(ONE)
		ONE is u8_heap_i24_item
		// if you want MINUS to be special
		// put a CHECK_HIGH_HALF in
		// looped COMPILES will optmise and RETAIN used
		// used DATA clogs up ROM, so limit to SAMPLE_SET
		//

		LIBR ROM space
		_u8_heap
		_i24_item_PAYLOAD
			ALIAS _i24_item = _i24_item_PAYLOAD
			FLAG EMIT _AS _%s_%s_%s "i24" "item" "PAYLOAD"
			// TOKENISE everything in ROM // SUBZONE += PLUS //

		u8_u24 HEAP_ITEM

			MINI_MACHINE has a LIST of 256 HEAPS
			MINI_MACHINE _HEAP has space for [u24_idx]

		u8_u12_u12_u12

			u8_opcode
			u12_one
			u12_two
			u12_three

	/*
	 	all these whacky interpretations work because

			I use different SPELLINGS for every field
			so they can appear o the page simultabeaously
			but 1 does not use the other

			TRUST LIBR to have been COMPILED by checking CXX

			This is the multi-parallel-universe-subsets
			all run in one namespace
			because they dont tread on eachothers toes

			COMPILE SCRIPT can see when EXPRS are not needed
			and pre-load those that usually are
			CT_RT might find a NULL and call CT_RT_needs_ITEM(ARGS)
			ARGS might be SQL_ENQ_ACK // and surrounding SESS_LOCK

			that is why REMOTE does run the script provided by us
			but it pre-filters it, to PRE_CALC_INIT_VAL
			that GEN_CODE SCRIPT to install that and complete
			ie ROM of COMPILED_SCRIPT is already available ".so"
			ie DLL already a builtin and trusted // runs in WRAP OK
			
	*/






	EDIT_TEXT

	The very FABRIC of CODE_DATA_SESS
	ARRAYS_LISTS_STRUCTS
	_have_API _WAX_WIDGET
	_A_FRAME /* all very 1980s */ // EMIT_OMIT "'" // "'" // PAIR_SYNC_EDGE
	_EDGE BOOKEND_PSG _BRACES_etc
	_A_DIAG {
	 _BASE += SCRIPT_CLASS_PSG_for_Phrase
	 _BASE += SYNTAX_around_PHRASE // += _and_FRIENDS
	 _BASE += _LIBR /* LIBR.BASE_TYPE_LIST += ITEM_TYPE_SPEC */
	 _CT_RT _CT
	 	THIS => _BASE // MENTION created INSTANCE of ITEM_SPEC
		// ALIAS SPEC TYPE
		// ALIAS ITEM = MK ITEM // ARGS // CTXT // API // LIBR // PLUS
		// MENTION brings in entire family tree in ROM
		// as part of some logic chain LIBR_UDEF ITEM.SPEC 
	 
	 	
	}


