	2024-09-02

	2024_09_Sep
	2024-09-02_EXEC_API_PROC_with_RPC_to_CORE.txt

	CACHE PREDICT
	CACHE
	 LOCAL
	 REMOTE
	 DIAG

	 	How each ENQ_ACK is processed
		can be codified, PRE_LOAD_CACHE _from_ROM
		ROM can be written, ELF_FILE_SEGMENT_UDEF
		 UDEF == CODE in CODE_SEGMENT_one 
		 UDEF == CODE loaded from FILE
		 FILE == nbytes_STO // possibly in a zone in a zone // elf_addr
		 UDEF == DATA_ROM // from CODE from INIT_DATA from ... // elf C
		 UDEF == DATA_STO // from MMAP HEAP ITEM AREA EA_EXPR

		 	DECODE script provides AVAR("ANYSTR")

			 MODE 
			  OPTION
			   require CIDENT99 // cident_97 is the SITE_SCRIPT LAYER
			 LAYER
			  SCRIPT
			  SITE_SCRIPT
			  UDEF_SCRIPT


	XS_BIAS

		API provides a PAIR of OPTIONS _SITE_ or _UDEF_
		_UDEF_
			// todo PERMIT WALL //
			// todo USED LIST // test_and_set EA_EXPR_MY_FLAG
			// u16_idx_EXPR // LEXICON += _u16 _idx _EXPR // _[0-9]
			// FILTER += CONVERT [0-9] to "_%s"
			// MINI // EA_below 64K is u16_idx_EXPR 
		_SITE_
			AKA "ROM"
			AKA "BUILTIN"
			_is TRUSTED when it doesn't add any CAPS CAPABILITIES
			_is TRUSTED when it doesn't use any CAPS LIST EDITS
			_is TRUSTED when it uses the API_REMOTE_REQUESTS
			_OPPS LOCAL REMOTE
			_ADJS TRUSTED UNTRUSTED PERMIT PERMITTED NOUN_ADJ
			_NOTE calls_trusted_API 

				FILTER: CALL_API_with_ARGS_SCRIPT { SCRIPT }

				 ARGS_SCRIPT {
				 	CT_RT_RERUN SET_ARGV0_or_NULL {
						// FALL BACK CODE HERE
						// MACRO_FFFF // NAME = RECALC
				 	 SET_ARGV0_or_NULL: {
					 	KNOW SET_ARGV0_or_NULL _ish
					 	PREP SET_ARGV0_or_NULL ARGS
					 	CALL SET_ARGV0_or_NULL JSR %s
						POST SET_ARGV0_or_NULL 

						SOMEONE must provide

						 SET_ARGV0_or_NULL

						Base class does

						 ARGV[0] = CALL_argv0 {
						 	# THIS.CACHED_as_INT
							# AUTO if %s == NULL
# AUTO PTR is itself a BOOL
						 	if NULL
							 RECALC()

						 }

						END_PREV
						START_ANOTHER_FUNCTION

					 RECALC:
					ASM for CALL_THIS_GETTER
					# THIS is THIS
					# GET_PTR _maybe_NULL
					# THIS is the PHRASE in action at XPOS
					# THIS is SESS.CSR_FFFF .XPOS
					# THIS is SESS.CSR_FFFF .PHRASE_two .XPOS
					# XPOS is SIMPLE and COMPLEX
					# XPOS abbreviates to u16_OFFS
					# XPOS abbreviates to i8_idx
					# XPOS abbreviates to i12_idx
					# XPOS abbreviates to i16_idx
					# XPOS abbreviates to i24_idx
					# XPOS abbreviates to i32_idx
					# XPOS OFFS
					# XPOS FILE OFFS
					# XPOS FILE LINE BPOS # CPOS #
/*
	If it is so easy to know CPOS from step by step CSET_glyph

	Then we can reply on CT_RT providing an API for

		CPOS = CPOS_from_BPOS( LINE_and_BPOS )
		BPOS = BPOS_from_CPOS( LINE_and_CPOS )

		The GCC and AMD_64_latest 
		can provide LIBS_ASM for this threads CPU level

			_level is a minimum
			so if you have mixed CORE of jumbles

				4 64_bit monsters
				2 64_bit simplified

				you have to register this CODE to require CORE
				require CORE with MMX_something // DONE //

			so if you have a list of machines

				N 64_bit_monsters

				 MMX_something is _MMX_none 
				 MMX_something is _MMX_IA32
				 MMX_something is _MMX_IA64_MMX_avoid // emu //
				 MMX_something is _MMX_IA64_MMX_basic
				 MMX_something is _MMX_basic
				 MMX_something is _MMX_latest
				 MMX_something is _MMX_profile_one
				 MMX_something is _MMX_profile_two
				 MMX_something is _MMX_profile_u4 // [0-9A-F]
				 // %1X //

			ASM for CSET glyph stepping over TEXT using MMX_fancy

				MMX_fancy_footwork

				 reserve MOST MMX registers // ie ALL // groups

			LIBR OFFS = BASE_ZERO + OFFS_of_LINE + BPOS

				API provides choice of BPOS or CPOS
				use in a wrapped holder with VTBL
				MMAP_HEAP_ITEM
				.SPEC
				.nbytes
				.VTBL_one
				.VTBL_two


			TUPLO XPOS FILE LINE CPOS

			i8_CPOS // lines should be i8 or i64 or i32_usually
			i24_CPOS // line limit // check on input
			i32_CPOS // default C type for "DECL: int CPOS"
			// PARSE DECL into fields and regen using SPELLING
  SPELLING

  	STR0 == "const char * STR0"
  	STR0 == "DECL: const char * STR0 = PRE_LOAD_from_PARAMETER" 

  ARGS_SCRIPT can do TOKENISATION from SPELLING

  	_SPELLING = PTR_STR0 // and nothing more
  	_SPELLING = fully_resolved_SPELLING
  	_SPELLING = partially_resolved_SPELLING

	arg_i = argv[idx++] // combine GETTER with AUTO_NEXT "++"
	// MACRO "arg_i = argv[idx++]" // combine GETTER with AUTO_NEXT "++"
	// { argv=argv; idx=idx; arg_i = argv[idx]; idx++; }
	// argv=argv is a well known NOOP to trigger VTBL_CALL get_ARGV()
	// idx=idx is a well known NOOP to trigger VTBL_CALL loop_idx_over_N()
	// NOTICE the above line is building a phrase, adding items
	// 
	// FUNC_MORPH for VIEW
	// MK AVAR /* TODO explain MK_AVAR and ANYSTR */ // PHRASE LIST
	if MATCH arg_i "arg_i = argv[idx++]"

	ARG_SCRIPT OPCODE

	PARSE OPCODE = "$1 = $2"
	PARSE arg_i = VAR_NAME_arg_i
	PARSE argv[idx++]"

	PARSE_OPTION ALIAS idx i NUMERIC

	NUMERIC == "NUMERIC"

		but with added CACHED_AVAR

		CT_RT knows how to adjust the SESS_TREE SESS_STREAM
		parsing STREAM of OPCODES and DATA and FURNITURE 

		MENTION triggers the creation of AVAR 

			XPOS_MENTION = XPOS FILE OFFS

				TUPLO does ASM_one but not ASN1
	
	ASM is managed code

		ASM is i8_DECODED
		ASM is i16_DECODED
		ASM is i32_DECODED
		ASM is i64_DECODED
		ASM is i32_u32_DECODED
		ASM is i8_i8_i16_i32

			BITFIELD SYSTEM ONE
			BITFIELD SYSTEM TWO
			BITFIELD COMPONENT LIBR_of_COMPONENTS

		VAR_POOL_HEAP {
			KNOW "EIGHT_t" // LOHI always in MEM in MMAP
			KNOW "i32_i32"
			KNOW "i8_i8_i16"
			KNOW "i8_i8_i16"; KNOW "i8_i8_i16" ; KNOW PAIR
			KNOW "i8_i8_i16_i32"
			KNOW "i8_i8_i16_i8_HEAP_i24_ITEM"
			KNOW "i8_i8_i16_i32"
			KNOW "i8_i8_i16_i32"
			expect "i8_HEAP" // MINUS is API
			expect "i8_ITEM" // MINUS is API
			array = SESS_HEAP_lookup("HEAP")
			array[ i8_idx_var ] of EIGHT_t
		}

		VAR_POOL {
			array[ i8_idx_var ] of EIGHT_t
		}
i8_idx_var 

	i8	BYTE_FIELD_EXPR
	idx	BYTE_FIELD
	var 	KEY_SPELLING("VAR_NAME")


*/

# AUTO PTR is itself a BOOL


					 }

					}

						PRE_LOAD require INIT_ZERO
						PRE_LOAD require INIT_NULL
						PRE_LOAD require INIT_M1
						PRE_LOAD require INIT_LOAD
						PRE_LOAD require INIT_CALC
				 }

	ARGS_SCRIPT

		ARGS_SCRIPT is a TRUSTED SCRIPT
		ARGS_SCRIPT runs fine in an UN_TRUSTED UDEF // script or STO
		 provided remote also uses NBYTES *
		 provided remote also uses FILTER: FILTER_EXPR_WITH_ARGS_SCRIPT

		ARGS_SCRIPT provides get_ARG1_into_place

			Running it does what it does (idx_it, SESS, PLUS)

			It may add any number of ARGS to ARGV
			It may rely on sequences without SKIPS

				SKIPS are JUMP_to_XPOS_on_AXIS

				AXIS = TIME_within_3_hours
				AXIS = TIME_within_24_hours // _25 
				AXIS = TIME_within_f64_seconds // GET_INT_TIME
				AXIS = TIME_f64_seconds // " %s as %s "


2024-09-02_EXEC_API_PROC_with_RPC_to_CORE.txt

	OK so LOCAL (HERE) to REMOTE (THERE)

	OK or SERVER (LOCAL) or SERVER (REMOTE)
	OK or CLIENT (LOCAL) or CLIENT (REMOTE)


	OK or ACTUAL (LOCAL) or ACTUAL (REMOTE)
	OK or CLONE (LOCAL) or CLONE (REMOTE)

	then as well as a look-alike-API_via_call_backs
	there is a second relay, around some bend
	that LOCN needs to convert DB_API text into actions

	PERMIT caller to download ROM_SCRIPT_LIVE_SAMPLES_FOLDER
	PERMIT caller to use MY_REF YOUR_REF
	PERMIT caller to trigger_on_MENTION

	PERMIT caller to run ARGV_SCRIPT
	PERMIT caller to run ARGS_SCRIPT

	get argv_idx // argv = get_ARGV idx_argv // key == idx //
	set argv_idx // argv[arg_idx] = VALUE
	cmp argv_idx_0 = argv_idx = 0 // LHS MID RHS // LHS = MID = RHS //
	// ALIAS LHS MID

