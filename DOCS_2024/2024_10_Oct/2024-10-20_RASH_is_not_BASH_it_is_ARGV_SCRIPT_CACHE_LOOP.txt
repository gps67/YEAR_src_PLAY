	2024-10-20

	2024_10_Oct
	2024-10-20_RASH_is_not_BASH_it_is_ARGV_SCRIPT.txt

	LIBR transfers ROM as massive nbytes

		but as a voucher to be claimed later

	LIBR transfers ROM as git_add new_files edited_files // from SWEEP

	SWEEP git_workflow is a series of snapshots - some stable

		REMOTE has already received ROM and LIBR from git_pull_recent

		sabotage detection can FILTER for
		 new_file starts_doing_strange_stuff



	SCRIPT is genuine login for purpose with permit
	SCRIPT purpose
	SCRIPT purpose LOGIN # negociating LOGIN and PERMIT setup cache

		AGREED API means that both LOCAL and REMOTE have matching caches

		We implement our own code, but we treat it as hostile.
		QUOTA_of_CPU_and_MEM_and_ANY_eg_thread_count

		Run SCRIPT in SESS.SANDPIT.SCRIPT
		Run SCRIPT in WRAP.SANDPIT.SESS.SANDPIT.SCRIPT

			many layers of nested calls can disappear to _two
			eg above is NEST.VAR.FIELD.ATTR
			eg ALIAS is NEST_VAR_FIELD_ATTR all_in_one_var

		CT_RT CODE_POINT SESS

			KNOW NEST is AVAR NEST ;# own 


 Parse
 DIAG of TEXT from TREE into TREE_CACHE_INFO_from_OTHER
 DIAG of TEXT from TREE into

	 TREE_CACHE_INFO_from_OTHER

	 	This is happenning on REMOTE
		who sees us as OTHER (REMOTES_REMOTE_IS_OTHER)
		their REMOTE is OTHER
	
	 TREE_CACHE_INFO

	 	carefully prepared STO
		in_SEGMENT ROM
		in_SEGMENT STO
		in_SEGMENT MEM
		describes TREE of ARGV_of_TREE_plus_DECL_LIST

			DECL LIST adds up to TREE_branches and FRUITS
	 TREE_CACHE_INFO

	 	DECL "{ DECL }" // Module_DECL allows USAGE ANY_OF_LIST

		MATCH ANY_of_LIST LIST

		 DECL_Module
		 DECL CONST
		 DECL TYPE_SPEC
		 DECL VAR
		 DECL FUNC
		 DECL FUNC _of_OBJ.SPEC.FUNC[idx_FUNC_%s] // prefix match
		 // DB SEARCH idx_FUNC /* _%s */  idx_FUNC_%s 
		 // DB SEARCH idx_FUNC_%s 
		 // DB SEARCH idx_FUNC
		 // DB SEARCH  ${ FUNC } // who gets $VAR probably MACRO
		 DECL TABLES_built_by_CT_RT and available to Module
		 DECL EXPR
		 DECL SCRIPT
		 DECL DATA_STO_SESS

 DIAG of TEXT from TREE into TREE_CACHE_INFO_from_OTHER

	We cant QUITE trust without ADDED CRYPTO_LAYER of PERMIT
	We need to be specific about what PERMIT is used for
	SCOPE limited to this PACKET and checksum_stack

	REMOTE is a chancer, an honest customer, or a thief

		SAFE_CODE SANDPIT is a false hope but better than nothing

		Your browser runs javascript for anybody
		this is the same, just added walls, permits, anti-dos

		anti-dos
			FILTER IP4 by KNOWN_LISTS and PRIORITIES

			established IP4 builds credit with each PERMIT 
			dos_connects_from IP4

	We are about to run code, that the LOGIN and PERMIT enables

		optimistically gets OK and LOCK
		LOCAL does COMPUTE of NEW
	
		one tactic is for set flags and leave
		book SYNC_EDGE over everything (CANT)
		some sticky LOCK wont budge, nor break for us
		That LOCK is a polite lovely, and brings flowers,

		We then have a SYNC edge in the future
		forms shapes ^||V

		-----/------/-- SYNC EDGE
		OLD  | OLD  |
 REQ SYNC EDGE	-----/      |	// CONDITIONAL GRANT NEW keeping OLD
		NEW  | OLD  |
		     /------/-- SYNC EDGE // release CONDITION effective actual
		NEW  | NEW  |
		-----/------/-- SYNC EDGE
		NEXT | NEXT |

		So the cache_loop between LOCAL and REMOTE
		LOCAL takes a ROLL_BACK_SNAPSHOT
		sends REQ_SYNC_EDGE to REMOTE //and FLUSH_ZERO_all_to_REMOTE
			A SPECIAL WAVE of SYNC_EDGE runs through CT_RT
			All queues are emptied, all buffers nudged
			This SYNC WAVE is rushing outwards
			This EXEC WAVE is rushing outwards - right behind
			works by calling one then the other
			and via API that specifies how this works
			basically SYNC_RUN_SYNC
			with all necessary PERMITS LOCKS DOCUMENTS
			becomes a momentary pulse, done in an instant

			MORE OPTIMISM can GUESS results in DATA
			so if this transaction ran
			the result would be
			needs actual_init_vals_wew_unchanged_since GOT_IT
	
	/// more thinking like this
	/// tell remote cache in advance, so it does not have far to request
	/// provide SYNC_EDGE ID - as our definition of "RECENT"

	LOCAL sends "set obj field to value" as ARGV_of_u32_u32
	LOCAL does TASK and changes DATA, sending more SET commands
	LOCAL seeks to SYNC those changes

	LOCAL BATCHES up thin_sliced_above into thick_sliced_bundle
	RECALC_IDS_AND_BUNDLE_API BUMBLE accumulates ENQ using SPLIT_WORLD
	PASS_FAIL_SPLIT SPLIT_PARALLEL_UNIVERSES_but_only_by_LIST

	future code must specify WHICH world it is on
	often a FAIL will back out
	often a PASS will call TEXT // where presume PASS is KNOW_PASS or good_guess
	often convert KNOW to VOTE and later to WEIGHT them multi_weight

		WEIGHT = bunch_of_switch_experiments then 20_60_40_5
 REF GOT_IT
 	DOCUMENT with any number of components, maybe none



