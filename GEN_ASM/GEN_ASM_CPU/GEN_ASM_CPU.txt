GEN_ASM_CPU/
GEN_ASM_CPU.txt

	avoiding qemu 
	avoiding llvm
	liking ARGV_is_OBJV // kind_of // DIALECT adds lots of AVAIL_EXPR near

	following CPU // starting with typical INT REG STACK INT


 in other words

 	4-CORE
 	4-CPU
 	2-CPU_DUO-4-CORE_THREAD

	 basically some silicon heads at Intel
	 designed a CPU with two brain halves sharing one outside

	 somehow their PLAN is "hyper-threading" 2 threads 1 bus
	 the design uses 2-sides multi-tasking for a bunch of local devices
	 cpu device might be a FPU_UNIT
	 cpu device might be a XMM_UNIT

	 	XMM is MMX and +1 the next evolution
		XMM is a hardware layout, such as the AMD64 with_options
		XMM is ROM_PROFILE + UDEF_PROFILE
		ROM_PROFILE
		 ARM_32_MODE
		 X86_32_MODE
		 X86_16_MODE_absent
		 ARM_64_MODE
		 X86_64_MODE
		MMX += XMM // new values old name // SCOPE RULE MATCH and GEN
		MMX is 8 registers
		EACH register is 128 bits
		Number of i256_fields in MMX

			| ROW[N_row]
			+----[0]------------------
			| 
			+----[1]------------------
			|
			+----[2]------------------
			|
			+----[3]------------------

https://docs.oracle.com/cd/E18752_01/html/817-5477/eojdc.html
		.
	.
	https://en.wikipedia.org/wiki/MMX_(instruction_set)
	AMD_64_Athlon // lacks SSE
	Extended MMX instructions = Pentium III SSE

https://en.wikipedia.org/wiki/MMX_(instruction_set)

MMX
	8x 64bit
	1_2_4_8 ints

XMM
	16x 128_bit

YMM
	16x 256_bit


AVX
	Q1 2011 intel
	later AMD Bulldozer, and Jaguar Puma

YMMX
	generic FPU SIMD Module YMMX
	simplifications required to switch when YMM is not available
	ancient XMM does not always have its derived YMM, even though we do

AVX-512
	32x 512 - also 32x YMM etc

OPTION	YMMX = XMM

	PAIR_i64_i64[N4=16] // MMX_N4 = MMX_N16 // 4BIT_TUPLO

DIALEXT BITFIELD_TUPLO can be WORD can be ITEM in NBIT see SPEC_of_same_index
DIALECT SPEC_of_same_IDX // KNOW LIST = ARRAY[IDX] of SPEC
DIALECT LIST is the wrong word for VECT or ARGV or OBJV or N_STEP

	XMM has 16 registers

	XMM[ idx_XMM ] is i128

		KEEP this a SINGLE amoungst PEERS
		ALSO a MINI_WORLD SCOPE TREE 
		USAGE i64_i64 
		 USAGE copy from XMM[register_idx] 

THINK_OF is a bit like MENTION

	AUTO KEEP ALLOC idx = N ++ // N == "N_%s" 

	u4_idx register_idx = SPEC_EXPR EA_of_AVAR 
		AVAR is a FPU_WORD_in_MMX_module // REQUIRE_XMM_SHIMS+
		
	REQUIRE MMX	or SHIM on other CPU
	REQUIRE XMM	or SHIM on other CPU

	PROVIDE -ditto-list-
	GEN foreach -ditto-list- {
		// STYLE last of ARGV is this BRACED SCRIPT
	} // could still add more here // think of as being mid stream
	// ARCHIVE has already accumulated ROM and STO and UDEF
	// MATCH SCRIPT found MID_ARGV // bool was_at_EOLN() { end_of_ARGV() }

	/*
		you are expected to know BASIC C++ and let AI BENCH EXPLAIN
		Our NON_AI implementation, offers various ways, PICKS, as_API
		PICKS makes the difference TEMPLATE+ARGS+SESS

		The jump into the void is allowing PROVIDE to work

			CACHE can model a reasonable REMOTE

				particularly when OWN_CODE_INVOKED_BOTH_ENDS

			CACHE_PREDICTS_REMOTE

				CT_RT helps by running CACHE_of_REMOTE_CODE
				also using NOT_YET_KNOWN as UNSET NULL
				other NULLS trigger a function_call() and ret_OK

			If we are lucky we can go the entire conversation
			without actually sending XMIT of ENK_ACK
			it is all PRE_LOAD or RUN_NOW to KNOWN and MEASURED

				needs ZONE_HEAP_ZONE

					an attempt at SAFE container for UDEF

					we actually allow UDEF to do block
					but only so we can both use the same 
					C++ MMAP code
					C may be an option
					// C_from_CXX //
					// CLANG_from_CXX // llvm 
					// GCC_from_CXX // 
					// GCC_inline_ASM // 
					// TP7
					// CLANG

				uses LIBR_ZONE_HEAP_ITEM

					LIBR uses a ROM area and a STO area
					LIBR uses a SESS api via CXX
				needs STO += VAR_POOL in ZONE_HEAP_ZONE

		The jump into the void is allowing REQUIRE to work

			we dont do this yet
			we PROVIDE actual simple BITFIELD_TECH
			GET_BITFIELD CPU_WORD << DROP_RIGHT 
			GET_BITFIELD CPU_WORD >> DROP_RIGHT + DROP_LEFT
			// ABOVE // SIGNED SHIFT // C uses ((i64)CPU_WORD)>> 


		

	*/


MINUS_ZERO_PLUS
	

	i256	crypto_line_256_bit crypto_block _256
	i256	i256 // NUMERIC INT SIGNED MINUS_ZERO_PLUS
	i256	QUAD_i64_i64_i64_i64 WORD_one_two_3_4
	i128	PAIR i64_i64 WORD_one_two // see also CODE_POINT WORD_xpos 
	i64

