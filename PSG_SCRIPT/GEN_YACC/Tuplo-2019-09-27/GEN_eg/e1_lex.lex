%{

// /////////////////////////////////////////////////////////////////////
// included from
// e1_lex.lex
// generated by
// gen_lex_top_code
//
#include <string>
#include "buffer1.h"
struct EXPR;
#include "e1.tab.hh"

/*
	lookahead may mean any number of tokens, not 1

	quick test shows actually OK 1 as long as yacc strdup's immediately
	but maybe
*/

// static const int nlex16 = 64;
static const int nlex16 = 16;
// static const int nlex16 = 1;
static buffer1 lex_buffer;
static buffer1 lex_pool[nlex16];
static int nlex_pos = 0;

 /*
 	lex found, return tok

	lex has found the string at yytext, yyleng
	use next storage slot (reuse nlex16 items later)
	copy string to buffer, as str0
	set yylval /union/ .lex_buff as returning string value
	return tok as lex type

 */
int lex_return( int tok )
{
	// skip first cell once, get it next time, or init -1
	nlex_pos = (nlex_pos+1) % nlex16;
	int pos = nlex_pos;
	lex_pool[ pos ].set( yytext, yyleng );
	yylval.lex_buff = (str0) lex_pool[ pos ];
	return tok;
}

// define SAVE_TOKEN  yylval.string = new std::string(yytext, yyleng)
#define TOKEN(t)    (yylval.token = t)

//
// e1_lex.lex END
//
// /////////////////////////////////////////////////////////////////////

%}

%option noyywrap

%%


\r\n	yylineno++; return TOKEN(LEX_EOLN);
\n   	yylineno++; return TOKEN(LEX_EOLN);
[ \t\r\n]   	return TOKEN(LEX_WS);

[a-zA-Z_][a-zA-Z0-9_]*  return lex_return( LEX_IDENTIFIER );
-?[0-9]+\.[0-9]*        return lex_return( LEX_DOUBLE );
-?[0-9]+                return lex_return( LEX_INTEGER );

"if"	return TOKEN(RW_if);
"while"	return TOKEN(RW_while);
"for"	return TOKEN(RW_for);
"do"	return TOKEN(RW_do);
"extern"	return TOKEN(RW_extern);
"return"	return TOKEN(RW_return);

"=="	return TOKEN(PUNCT_CEQ);
"!="	return TOKEN(PUNCT_CNE);
"<"	return TOKEN(PUNCT_CLT);
"<="	return TOKEN(PUNCT_CLE);
">"	return TOKEN(PUNCT_CGT);
">="	return TOKEN(PUNCT_CGE);
"="	return TOKEN(PUNCT_EQUAL);
"("	return TOKEN(PUNCT_LPAREN);
")"	return TOKEN(PUNCT_RPAREN);
"{"	return TOKEN(PUNCT_LBRACE);
"}"	return TOKEN(PUNCT_RBRACE);
"."	return TOKEN(PUNCT_DOTOK_);
","	return TOKEN(PUNCT_COMMA);
"+"	return TOKEN(PUNCT_PLUS);
"-"	return TOKEN(PUNCT_MINUS);
"*"	return TOKEN(PUNCT_ASTERISK);
"/"	return TOKEN(PUNCT_SLASH);
"^"	return TOKEN(PUNCT_CARET);
"&"	return TOKEN(PUNCT_AMPERSAND);
"%"	return TOKEN(PUNCT_PERCENT);
"|"	return TOKEN(PUNCT_PIPE);


. printf("Unknown token!\n"); yyterminate();

%%
