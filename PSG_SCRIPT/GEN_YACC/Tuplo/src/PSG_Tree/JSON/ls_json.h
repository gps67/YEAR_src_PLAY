#ifndef ls_json_H
#define ls_json_H (STR0 "base2_api_CXX_JSON %s STR0 name") // ASIS ARGV 
// ARGV Name "STR0" // VIA "LISPY_LEX ARGV_LEX" // INDENTED_BLOCKS_of_LINE[S]
// ARGV ADDR "EA1" // EA = MINI_MACINE INIT_VALS INIT_SCRIPT -via- GETTER
// ARGV DATA "EA == lookup %s" // MENTION creates CODE_POINT // as_LIST 
// ARGV_as_OBJV // _with _LIBR.EXPR ( ARGV ) // VALUE == VAR("EA0") // THIS //
// ARGV_with_SCRIPT // SCRIPT[S] // SCOPE += ANY_on_MENTION // ALIAS // 
// OBJV_knows_TEMPLATE_and_FIELD_VALS // SCRIPT // CTXT // ENV // ALIAS // %s //
// MODULE // CODE_POINT // KNOWN_VALUE_FOUND_at_CODE_POINT // XPOS //
// XPOS HERE //

// ls_jsaon // api_to_list_dir // ab it like ls but as ls_api
// ls_jsaon // api_to_list_dir // obj == EA //
// ls_jsaon // api_to_list_dir // obj == LIST_of_FS_DIR_LIST_object ibj_idx_t //

// #include "ls_jsaon_api.h"  // 
#include "ls_jsaon_api_obj_api.h"  // THIS is PTR to a STRUCT of_atleast_type_T

	// AS CXX_OBJ
	// AS SPELLING STR0 == "STR0"
	// AS SPELLING { STR0 == "STR0" } // PSG += THIS SAMPLE
	// DECODE LEX STEPS from multi_part_lex_IDENT // IDENT == ALIAS //
	// FILTER PERMIT { IDENT == ALIAS } be MKVAR("ALIAS") 
	// or ALIAS
	// or STR0
	// or SELF
	// or NAME
	// or ITEM
	// or EXPR // others get their local ea // u24_idx // ELSE AUTO FAIL //
	// or EXPR // EA // PTR // SESSION_VAR("STR0") // make name of type
	// STR0_t STR0 // first STR0 is often SELF "{ OBJ_t OBJ }" // ALIAS ...
	// MK_POOL_of_NAMED_ITEM_t ITEM_xF // _x0 MATCHES SELF THIS ITEM ALIAS
	// AUTO_BENCH MATCH("_xF") in SUBLEX
	// AUTO_BENCH MATCH("STR0") in SUBLEX // KNOW is BY_STR0 SPELLING
	// SPELLING == "SPELLING"
	// SPELLING == "STR0"
	// SPELLING == "ALIAS"
	// SPELLING == "%s" // BENCH MATCHES THIS PATTERN as LEX("%s")
	// SPELLING == "SPELLING" // VAR_NAME == "SPELLING" // MATCH LEX ARG
	
	// ITEM += ONE OF dir file symb_link device EXPR == "LIST_of_ITEM"
	// ITEM += UNIX_STAT // API for WIN32 LIST_DIR // 
	// I think that we can provide LS_LIST_of_FILES _and_FS_ITEMS 
	 


#endif

