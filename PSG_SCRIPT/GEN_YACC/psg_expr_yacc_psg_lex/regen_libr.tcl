# regen

namespace eval regen {

  # module object variables

	variable text_yacc_top_code {}
	variable text_lex_top_code {}
	variable EXTRA_TOKEN_list {}
	variable PUNCT_list {}
	variable RW_list {}
	# what is initialiser of array ?
	variable PUNCT_token_of_punct
	variable PUNCT_punct_of_token
	variable RW_token_of_word
	variable RW_word_of_token


  proc init {} {
	# set ::regen::text_yacc_top_code {}
	# set ::regen::PUNCT_list {}
	# set ::regen::RW_list {}
  }

  proc TEXT {outvarname text} {
	upvar $outvarname out
	# remove leading EOLN from text - one only # todo
	# add trailing LF - if missing # todo
	append out $text
  }

  proc LINE {outvarname {text {}}} {
	upvar $outvarname out
	# remove leading EOLN from text - one only # todo
	# add trailing LF - if missing # todo
	append out $text "\n"
  }

  proc EXTRA_TOKEN {token} {
	variable EXTRA_TOKEN_list
	lappend EXTRA_TOKEN_list $token
  }

  proc PUNCT {punct token} {
	variable PUNCT_list
	variable PUNCT_token_of_punct
	variable PUNCT_punct_of_token
	lappend PUNCT_list $punct
	set PUNCT_token_of_punct($punct) $token
	set PUNCT_punct_of_token($token) $punct
  }

  proc RW {rw {alias {}}} {
	variable RW_list
	variable RW_token_of_word
	variable RW_word_of_token
	if {$alias=={}} {
		  set alias $rw
	}
	set token RW_$alias

	lappend RW_list $rw
	set RW_word_of_token($token) $rw
	set RW_token_of_word($rw) $token
  }

  # HOWTO multiple tail args
  proc RWS {args} {
	  foreach arg $args { 
		  RW $arg
	  }
  }

 # yacc generates the token enum
 # we want this too 
 #
  proc gen_str_of_token {outvarname} {
	upvar $outvarname out
	variable RW_token_of_word
	variable RW_list
	variable PUNCT_list
	variable PUNCT_token_of_punct
	LINE out 
	LINE out " const char * str_of_token( int tok ) \{"
	LINE out "  switch( tok ) \{"
	foreach rw $RW_list {
		set tok $RW_token_of_word($rw)
		LINE out "   case $tok:\treturn \"$rw\";"
	}
	foreach rw $PUNCT_list {
		set tok $PUNCT_token_of_punct($rw)
		LINE out "   case $tok:\treturn \"$rw\";"
	}
	LINE out "   default:" 
	LINE out {    static char as_hex[20];}
	LINE out {    snprintf( as_hex, sizeof(as_hex), "x%2X", tok );}
	LINE out {    return as_hex;}
	LINE out "  \}"
	LINE out " \}"
  }

  proc lex_GAP_list {outvarname} {
	upvar $outvarname out
	EXTRA_TOKEN LEX_EOLN
	EXTRA_TOKEN LEX_WS
	# NO # LINE out "// # LEX RULES gap"
	LINE out 
	LINE out "\\r\\n	yylineno++; return TOKEN(LEX_EOLN);"
	LINE out "\\n   	yylineno++; return TOKEN(LEX_EOLN);"
	LINE out "\[ \\t\\r\\n\]   	return TOKEN(LEX_WS);"
	LINE out 
  }

  proc lex_EXPR_list {outvarname} {
	upvar $outvarname out
	EXTRA_TOKEN LEX_IDENTIFIER
	EXTRA_TOKEN LEX_DOUBLE
	EXTRA_TOKEN LEX_INTEGER
	# NO # LINE out "# LEX RULES exprs\n"
	LINE out {[a-zA-Z_][a-zA-Z0-9_]*  return lex_return( LEX_IDENTIFIER );}
	LINE out {-?[0-9]+\.[0-9]*        return lex_return( LEX_DOUBLE );}
	LINE out {-?[0-9]+                return lex_return( LEX_INTEGER );}
	LINE out 
  }

  proc lex_RW_list {outvarname} {
	upvar $outvarname out
	variable RW_list
	variable RW_token_of_word

	# NO # LINE out "// # LEX RULES reserved words\n"
	foreach rw $RW_list {
		  set token $RW_token_of_word($rw)
		  LINE out "\"$rw\"	return TOKEN($token);"
	}
	LINE out
  }

  proc lex_PUNCT_list {outvarname} {
	upvar $outvarname out
	variable PUNCT_list
	variable PUNCT_token_of_punct
	# NO # LINE out "// # LEX RULES punctuation\n"
	foreach rw $PUNCT_list {
		  set token $PUNCT_token_of_punct($rw)
		  LINE out "\"$rw\"	return TOKEN($token);"
	}
	LINE out
  }

  proc gen_lex_top_code {outvarname} {
    upvar $outvarname out
    TEXT out {
// /////////////////////////////////////////////////////////////////////
// included from
// e1_lex.lex
// generated by
// gen_lex_top_code
//
#include <string>
#include "buffer1.h"
struct EXPR;
#include "e1.tab.hh"

/*
	lookahead may mean any number of tokens, not 1

	quick test shows actually OK 1 as long as yacc strdup's immediately
	but maybe
*/

// static const int nlex16 = 64;
static const int nlex16 = 16;
// static const int nlex16 = 1;
static buffer1 lex_buffer;
static buffer1 lex_pool[nlex16];
static int nlex_pos = 0;

 /*
 	lex found, return tok

	lex has found the string at yytext, yyleng
	use next storage slot (reuse nlex16 items later)
	copy string to buffer, as str0
	set yylval /union/ .lex_buff as returning string value
	return tok as lex type

 */
int lex_return( int tok )
{
	// skip first cell once, get it next time, or init -1
	nlex_pos = (nlex_pos+1) % nlex16;
	int pos = nlex_pos;
	lex_pool[ pos ].set( yytext, yyleng );
	yylval.lex_buff = (str0) lex_pool[ pos ];
	return tok;
}

// define SAVE_TOKEN  yylval.string = new std::string(yytext, yyleng)
#define TOKEN(t)    (yylval.token = t)

//
// e1_lex.lex END
//
// /////////////////////////////////////////////////////////////////////

}	;# text quote
  }

  ##############################################################
  proc gen_yacc_top_code {outvarname} {
    upvar $outvarname out
    TEXT out {
          #include <cstddef>
          #include <stdio.h>
  //      #include <string>
          extern const char * str_of_token( int token );
          #include "EXPRS.h"
          using namespace EXPRS;
          #include "e1.tab.hh" // bison lists PUNCT_PLUS as int
          #include "str1.h"
  #if 0
          struct YYSTYPE;
          struct YYLTYPE;
          int  yylex (YYSTYPE*, YYLTYPE*);
  #else
          int yylex(void);
  #endif
          extern int yylineno;
          extern char * yytext;
          // extern "C" int yyparse ();
          extern int yyparse (void);
          void yyerror(const char * msg) {
                  printf("# ERR # line %d # %s\n", yylineno, msg );
          // no   printf("# ERR # col %d # %s\n", @$.first_column, msg );
          }
    }
  }

  ##############################################################
  proc gen_yacc_rules_code {outvarname} {
   upvar $outvarname out
   TEXT out {
// expr_ident : LEX_IDENTIFIER { $$ = E1( $1 ); }

// expr_ident : LEX_IDENTIFIER { $$ = E1( "LEX_IDENTIFIER" ); }
expr_ident : LEX_WS expr_ident { $$ = $2; }
expr_ident : expr_ident LEX_WS { $$ = $1; }
expr_ident : LEX_IDENTIFIER { $$ = E1( yylval.lex_buff ); }

BOP	: 
	  PUNCT_MINUS
	| PUNCT_SLASH
	| PUNCT_PERCENT
	| PUNCT_PIPE
	| PUNCT_AMPERSAND
	| PUNCT_COMMA
	;

// // this is re-branding expr sp as an expr of priority 123
// expr : LEX_WS expr { $$ = $2; }
// expr : expr LEX_WS { $$ = $1; }

expr : expr PUNCT_PLUS expr { $$ = E_plus_E( $1, $3 ); }
expr : expr PUNCT_ASTERISK expr { $$ = E_times_E( $1, $3 ); }
expr : expr PUNCT_CARET expr { $$ = E_power_E( $1, $3 ); }

expr    :       LEX_WS expr LEX_WS { $$ = $2; }
	|	expr  BOP  expr { $$ = E2( $1, $2, $3 ); }
	|       PUNCT_MINUS  expr  { $$ = E1( $1, $2 ); }   
//	|       '-'  expr      %prec  '*'
	|	expr_ident { $$ = $1; }
	|	PUNCT_LPAREN expr PUNCT_RPAREN { $$ = $2; } // keep not of () ?
	;

// no match on eoln ?
// example Left Recursive list (without the list builder)
lines
: %empty
| lines line

line : expr LEX_EOLN { EXPR * E = $1; E->printer(0); }

top: lines

   } ; # LINE out
  }
  ##############################################################

  proc gen_union {outvarname} {
    upvar $outvarname out
    LINE out 
    LINE out "// yylval . fieldname"
    LINE out 
    LINE out "%union {"
    LINE out "  EXPR * expr;"
    LINE out "  int token;"
    LINE out "  const char * lex_buff;"
    LINE out "}"
  }

  proc gen_tokens {outvarname} {
    upvar $outvarname out
    variable RW_list
    variable PUNCT_list
    variable EXTRA_TOKEN_list
    variable PUNCT_token_of_punct
    variable RW_token_of_word
    foreach rw $RW_list {
	    set tok $RW_token_of_word($rw)
	    LINE out "%token <token> $tok"
    }
    foreach punct $PUNCT_list {
	    set tok $PUNCT_token_of_punct($punct)
	    LINE out "%token <token> $tok"
    }
    foreach tok $EXTRA_TOKEN_list {
	    LINE out "%token <token> $tok"
    }
  }

  proc gen_type {outvarname lhs rhs} {
    upvar $outvarname out
    LINE out "%type <$lhs> $rhs"
  }
  proc gen_types {outvarname} {
    upvar $outvarname out
    gen_type out expr expr_ident
    gen_type out expr expr
    gen_type out token BOP
  }

  proc gen_left_right {outvarname} {
    upvar $outvarname out
    LINE out "%right PUNCT_CARET ///////// dumb"
  }

} ;# namespace eval regen
