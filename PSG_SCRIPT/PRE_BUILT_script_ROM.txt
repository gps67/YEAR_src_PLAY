
 YEAR/src/PLAY/PSG_SCRIPT

	PRE_BUILT_script_ROM		.txt

	SCRIPT gets tokenised in 2 worlds
	 LOCAL
	 REMOTE
	
	BOTH are PREBUILT from same version = NOW || SUPPORTED // NOW only

	 Previous compile was for source identical with this source

	 shared OLD file, TREE held in ROM with CVS external

	  { SHARED }

	 Previous compile was for source EDITED from that source

	 MATCH LOCN = SAMEID__DIFFERENT_VERSION

	 	EA_LOCN = SAME = 
		EA_DATA = WHEN = CVS_PICKER
		 STO_LHS // LOCAL
		 STR_RHS // REMOTE

// { USAGE LHS RHS } // { LOCN.STO LOCAL REMOTE }

	POSSIBLE SITUATION
	 I am REMOTE
	 
	 LHS RHS <--> LOCAL REMOTE // as seen by TCP_Client
	 LHS RHS <--> LOCAL REMOTE // as seen by TCP_Client then by TCP_Server
	 LHS RHS <--> CLIENT SERVER // as seen be each over duplicated Tree

	 POSSIBLE SITUATION
	  I am Server

	  I am offering the one and only version of the software ROM
	  I can generate the new ROM (and often do)
	  I can patch OLD --patch--> NEW
	  NO-NEED tho because BOTH running on latest SCRIPTS from SERVER
	  So it keep being an exact match

	  Client can only call scripts that the server chooses to provide
	  Client can only EDIT data on the Server, which it has present

	   ROM_Tree that means that the OBJECT must be duplicated
	   ROM_Tree that means that every OBJECT ON STACK (already is)

	   EDIT = 
	   	START with ROM Object COPY to STO_RW add indexes maybe

		STEP down into OBJECT (Tree) 

			REQUIRE HERE on STACK
			REQUIRE HERE on STO_RW
			FLAG Modified since ROM

		HERE with ROM  Object COPY to STO_RW add indexes maybe

			EDIT LIST SEQUENCE

			sel bubbles up one
			sel bubbles down one

			LIST sorts by K1 K2 K3 ...
			LIST sorts by mtime
			LIST sorts with subgrouping chapters apart
			LIST can be displayed using VIEW data + code
			LIST add column RANK
			LIST via VIEW with RANK.from.RAND

			LIST LAYOUT = extra column on LIST Ranking Position

	Client
		runs the servers script,
		to simulate what the server will be doing
		gets the same results, predicts, reacts
		gets the same questions, prepares, waits

		runs the servers script by RPC

			can only call predefined code
			can write SCRIPTS over that

		doesnt run many scripts, unless server does RPC
// LATE EOT // 

	all SCRIPTS get screened
	all SCRIPTS get tokenised
	all SCRIPTS get imports 

		limit SCRIPT to unsafe_coda_can_call_this

			eg VFS can provide VFS services
			to VFS area FOUR // VFS_USER

		permit SCRIPT with CAN_DO_Permit

			QUOTA $TMP/private/data  using 20 MB
			QUOTA $STO/here/data     using 2 MB
			QUOTA MMAP_DATA		using MMAP_FILE_40G
			QUOTA MMAP_AREA		using MMAP_FILE_1G

		permit SCRIPT to 4 x fd = MMAP_FILE SUB_ZONE

			fd = MMAP_FILE SUB_ZONE

			fd_0 = MMAP_FILE ROM_0
			fd_1 = MMAP_FILE_STO_RW_1
			fd_2 = -1
			fd_3 = -1

	Many scripts will be identical - run the PREBUILT

	PATCHED / EDITED scripts, will be above to call

		call original CODE EXPR
		call SCRIPTED code EXPR

			script has been screened
			script has been tokenised
			EDIT even gets the SMAE ID for SAME SUB EXPR
			recompiled against regenerated symbol tables
			(the ones already in the ROM, clever distance parallel)

		call LIST_of_STEPS
		call FUNCTION = lookup attach parameters call eval return
		call FUNCTION = lookup BUILTIN parameters call eval return

		call LOCN = if, while, case, yadda, yadda, variation of STEP

		CALL STEP

 TRUST -> PERMIT

 	It's your data, you can edit your data,

 SCRIPT tokenised

 	so CAN EXPECT / DEMAND / FILTER PROVIDE

	that tuplo stream can be N_LIST of trustable N

	 tuplo.N_LIST.N=5

	  tuplo.ITEM_todo_str = cairo
	  tuplo.ITEM_todo_str = yacc gen
	  tuplo.ITEM_todo_str = yacc use
	  tuplo.ITEM_todo_str = mmap_file
	  tuplo.ITEM_todo_str = EDIT_Tree

	  tuplo.NEXT // ok require NULL at/after end

	 tuplo.LIST.N = unknown - look for NULL

	  tuplo.ITEM_todo_str = cairo
	  tuplo.ITEM_todo_str = yacc gen
	  tuplo.ITEM_todo_str = yacc use
	  tuplo.ITEM_todo_str = mmap_file
	  tuplo.ITEM_todo_str = EDIT_Tree

	  tuplo.NULL
	  tuplo.NEXT // untouched // unread

EDIT
	  tuplo += EDIT_Tree
	  tuplo += dset_api // TCP_SQL_T0T2_Time_Value_Stream_buffers

	  VAR CHUNK_IN = VAR_Type("{ ... Time Value ... }"

	  YEAR/src/libs_apps/src/sar_data/dset/dset_api.h
	  YEAR/
	   src/
	    libs_apps/
	     src/
	      sar_data/
	       dset/
	        dset_api.h

EDIT      += PSG_SCRIPT

	  tuplo += EDIT_Tree PSG_SCRIPT
	  // EDIT_request is a part of SCRIPT
	  // EG OLD <--> NEW // NEW from BULK_patch
	  // DECL <tree_locn> // auto_import twig from graft

	  tuplo += RPC_EDIT // PKT_IN == EDIT_step

	  VAR CHUNK_IN = VAR_Type("{ ... Time Value ... }"

	  YEAR/src/libs_apps/src/sar_data/dset/dset_api.h
	  YEAR/
	   src/
	    libs_apps/
	     src/
	     # VIEW LIST #
	     src/sar_parse/sar_hpux
	     src/sar_data/dset/dset_api.h
	     src/sar_parse/tbl_collect/tbl_col_floats_wrap.h
	     src/sar_parse/tbl_collect/tbl_collect.h
	     # VIEW TREE #
	      sar_parse/
	       sar_hpux/	// example UDEF user of data
	       sar_data/	// 

	      sar_parse/
	       sar_hpux/

	      sar_parse/
	       sar_data/

	       tbl_col_floats_sar.h

	       tbl_col_floats_sar
	       tbl_col_floats_wrap

	      sar_data/
	       dset/

	        dset_api.h

(( UNJUMBLE )) 
	NAMESPACE
	 TBA
	  MODULE
	   sql_BLOB_type // Tree += SPEC += STO += PKT_IO
	   sar_plot // here PROVIDING a MODULE that should match SQL_BLOB_TYPE
	   DIR
	    tbl_collect
	     tbl_col_floats_base.cxx .h
             tbl_col_floats_wrap.h
             tbl_collect.cxx .h
	    

 class tbl_collect	// editable data, time-series-chunks, QIO, actions

 	mem_line_spec spec1; // default values host=box5 cmd=sar
	time_t time0; // TODO ADD time2_clipping_line

	dyn_array<tbl_col_floats_base *> data;

	 dyn_array<float> ary; // VECTOR of float32 // plenty of accuracy
         mem_line_spec spec; // the line of data
         time_t t0; // CHUNK.t0 // dt_N = dt * N // t2 = t0 + dt_N

	 This VECTOR of data is compattible with dset_api
	 dset_api (base class) CHUNKS to/from SQL TimeSeries_CHUNKS
	 
	 sar_data /  mem / mem_line_type .h

	   enum Point_or_Series { M1=-1, // AUTOCODE adds UNSET markers M1 -1
                series,
                point_date,
                point_time,
		// CHUNK of // your line type here
		// FINDABLE via SQL search for mem_line_spec // NEEDS * EXACT
		// MIME // will probably have Tree of item type, 
		// MIME // meet TimeSeries_DATA_in_a_Tree_by_a_Stream
		// SQL // QUERY // EXACT EA // KEY // IN_LIST // a_bit_like
		// 
           };

        Point_or_Series val;







