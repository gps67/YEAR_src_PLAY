# from app_item import app_item, libs_apps_item, app_list, app_dict
from app_item import app_item, libs_apps_item

sar_gather = app_item( "sar_gather" )
sar_gather.lang = "ksh"
sar_gather.desc_line = "edit crontab to collect SAR -AMS data"
sar_gather.desc_text = """
	This is a simple READABLE ksh script(s) to collect stats.
	You can read it for security, and install it on your HP/SUN/AIX/True64/... boxes.

	Even if you dont have the SAR parser running (yet), get this in cron
	now. (You cant plot data that you dont have).
"""

libs_apps = app_item( "NOTES" )
libs_apps.lang = "LGPL NOTES for stuff to sort out"
libs_apps.desc_line = "TEXT scratchings for 2011"
libs_apps.desc_text = """
	HAPPY NEW YEAR!! Its time to dust off SCAN, make it parse SCRIPTS,
	built a TREE STO that contains lots of C snippets,
	and generate C or C++ code from those bits (HaHa!!).
	Here are the latest meanderings, in .txt format

"""

libs_apps = app_item( "libs_apps" )
libs_apps.lang = "C++ gtk"
libs_apps.desc_line = "A moderate set of libraries and apps "
libs_apps.desc_text = """
	libs_apps is a code platform (libs) driven by a few tasks (apps).
	It has a refCounted, C++ object model, some containers, text
	buffers, wrapped_gtk_objects, linux device mixers (wrapped api),
	infra-red-api-wrapped, PDF generation, CSV accounting,
	JavaScript instumentation, persistent MMAP object storage,
	sar_parse, 
	sar_plot display,  ... all my code is moving into here
	(but I am going to move some of the experimental code out to ../IDEAS).
	The build system, is not out-of-the-box, but does cross-compile
	for WIN32, which is getting more api support (some kludged) these days.
	You're not supposed to use it all at once, I'm just pooling it
	so that it integrates, and grows in sync.

"""

SPIN_py = app_item( "SPIN_py" )
SPIN_py.lang = "C++ Python Module"
SPIN_py.desc_line = "SGML Parser 'SP' integrated as a Python module" 
SPIN_py.desc_text = """
	SP is the best Open Source C++ SGML Parser http://www.jclark.com/
	
	SPIN_py is a Python module that uses SP's generic interface
	to provide a SAX-like (but different) stream of events, which
	you can hook to Python expressions, and build a tree (not DOM).

	This page is generated by SPIN_py/SPIN_test_zone/test_gen_2_LGPL
"""

Pythag = app_item( "Pythag" )
Pythag.lang = "Python/Tk"
Pythag.desc_line = " illustrate a proof of Pythagorus' triangle "
Pythag.desc_text = """
	Ever wanted to prove pythagorus? Where do you start?
	This script creates a little animation, that might help.
---
	When you see the shape, its pretty obvious that the bits add 
	up to the whole, but you must check that what you expect
	is what is really there. Is it really square?
---
	ALSO: a tray of perfect ball bearings form a pattern, but is
	that approximate or exact? Do 6 exactly surround 1 without
	rattle or being squashed?
---

	(BUG: win32 draws OK but doesnt animate, run on Unix)
"""

mp3_hissy = app_item( "mp3_hissy_fit" )
mp3_hissy.lang = "Python"
mp3_hissy.desc_line = "process a tree of files, .wav .mp3 .cddb, least hiss, most fit"
mp3_hissy.desc_text = """
	MP3 files are compressed WAV files. This script uses cdda2wav
	to put the WAV files in the right places, and get the .cddb file.
	It then uses the .cddb file to rename the dir/files, and tag the mp3's

	You can ask LAME to give you different quality levels.
	-V0 means bigger files with less hiss, -V9 means more will fit on your player,
	but sound too hissy. -V4 seems OK for non-headphones
	So you load the CD with cdda2wav (hissy -rip_here),
	and then produce different trees at different compression
	levels, then copy the files that fit to your player.
	Then change your mind, and rebuild a new tree at the new level.
"""

snmp1 = app_item( "snmp1" )
snmp1.lang = "C++"
snmp1.desc_line = " Example SNMP program in C++ "
snmp1.desc_text = """
	http://www.net-snmp.org/ is a C library for SNMP servers and clients.
	
	snmp1 is an example C++ client, its really an experimental
	C++ wrap, of simple gets, with asynchronous responses.
"""

if 1:
	NWA_parse = app_item( "NWA_parse" )
	NWA_parse.lang = "Python"
	NWA_parse.desc_line = "parse FullStatement.csv from Nationwide Anglia"
	NWA_parse.desc_text = """
		Nationwide Anglia online banking service, provide a 
		downloadable FullStatement.csv.
		
		This Python script parses the CSV, and makes a series of reductions,
		recognising standard string expressions. Things like standing orders,
		currency convertions from european ATM's, and the town for each shop.
	"""

PATH_TOOL = app_item( "PATH_TOOL" )
PATH_TOOL.lang = "C++"
PATH_TOOL.desc_line = "change PATH or other variables "
PATH_TOOL.desc_text = """
	A C program to add/del items from a PATH like variable.
	
	The program filters out duplicates, which may help speed,
	and it makes shell scripts a bit more readable. It now has a new
	option to allow duplicates, and use spaces, to build command
	lines.
	
	NB in order to set a variable, (not in a sub-program), you need
	to have 'dot-included' a function that calls the C prog.
"""

hp_info = app_item( "hp_info" )
hp_info.lang = "ksh"
hp_info.desc_line = " Gather some info about an HP/UX box and its LVM layout "
hp_info.desc_text = """
	A list of commands that might tell you how an HP/UX box is configured.
	along with a full text dump of the LVM layout.
	
	You edit the list of commands to add any missed ones, or comment out
	any data that your policy says to not grab.
"""

tools_2000 = app_item( "tools_2000" )
tools_2000.lang = "ksh"
tools_2000.desc_line = "Build a standard GNU toolchain in a sensible prefix "
tools_2000.desc_text = """
	This is a collection of shell scripts that do the following:
	
	./configure --prefix=/tools/2000/ccs
	
	The above is easy enough, but sometimes there are additional
	parameters, and its nice to have help putting the files
	into the right directories, and keeping source without objects.
	
	I use these scripts to bootstrap/build the GNU toolchain,
	and a list of well known + needed apps, and put them into
	SEVERAL DIFFERENT prefixes. That assists maintaining versions
	eg /live/web_one/ -vs- /test/web_two/
	
"""

mm3_scan = app_item( "mm3_scan" )
mm3_scan.lang = "C++"
mm3_scan.desc_line = " Parse file.mm3 (old accounts) "
mm3_scan.desc_text = """
	Money-Manager is a proprietry (DOS) accounting program.
	
	mm3_scan parses its files to export it elsewhere.
	
	This code is old and untidy, but it retains access to
	legacy files, and it doesnt fall over.
"""

s_time = app_item( "utils_misc" )
s_time.lang = "C"
s_time.desc_line = "Misc Utils that do useful things"
s_time.desc_text = """
	s_time adjusts the time, updates the hardware clock,
	and shows a synchronised count, perror prints errno, un_hex
	convers hex to binary, overwrite_file fills a file
	with NULs, with writes aligned at boundries, 
	(cured a bad-block on the disk), PATH_TOOL edits
	shell vars like LD_LIBRARY_PATH.
"""

s_time = app_item( "s_time" )
s_time.lang = "C"
s_time.desc_line = "adjtime by a number of seconds"
s_time.desc_text = """
	Currently I use the 'NET to get the time at boot,
	but when I was modem connected, this was very useful,
	as this PC's clock drifts quite a lot.
"""

un_hex = app_item( "un_hex" )
un_hex.lang = "C"
un_hex.desc_line = "convert ascii 2-byte hex numbers to bytes"
un_hex.desc_text = """
	This convert from ASCII hex dumps back to DATA.
"""

web_play = app_item( "web_play" )
web_play.lang = "PHP"
web_play.desc_line = " PHP login and session "
web_play.desc_text = """
	Some PHP scripts and MySQL tables that track a login session.
	
	The client browser keeps a single cookie, which is the session-id,
	and a random secret for the session.
	
	No other data is kept in the cookie, or in the URL. This allows
	the user to bookmark pages.
	
	If no login has happened, the user gets a new session as the 'ANON'
	user. If the page needs some permit that the current user doesnt have,
	it can fail or send what it wants (no output yet sent).
	With forms and functions to handle login.
	
"""

if 0:
 backs = app_item( "backs" )
 backs.lang = "sh"
 backs.desc_line = " Backups of .xawtv "
 backs.desc_text = """
	 There should be nothing dangerous here (RSN)
 """

ideas = app_item( "IDEAS" )
ideas.lang = "C++"
ideas.desc_line = " Ideas: not quite sane ones "
ideas.desc_text = """
	This is a cooking pot where there are lots of half baked ideas.

	libs_apps will gradually move some of its chaff here.

	FP256 - fixed point arith and printer.

	bio - ssl bio as fd_selectable_ssl.

	enum_group - names against ints.

	loob - loob is not bool (eg pointer || NULL).

	slog1 - beginnings of syslog client/daemon.

	OBJ - how a pointer to an obj might look.

	ping - (using gtk_main solved deafness)

	Open_File/Counting_in_BINARY_From_Zero


"""

if 0:
	food = app_item( "food" )
	food.lang = "docs"
	food.desc_line = "links to recipes"
	food.desc_text = """
		Pastry and wine
	"""

if 0:
	tests = app_item( "bug_rep_1_button" )
	tests.lang = "PHP"
	tests.desc_line = "dvdauthor bug - entire screen is 1 button"
	tests.desc_text = """
		this is a PHP script that generates a menu's .png images
		Except that it doesnt work. TIA
	"""

tests = app_item( "scan" )
tests.lang = "C++"
tests.desc_line = "a parser to scan general texts"
tests.desc_text = """
	This is a general purpose parser I attempted some 10 years ago, and has
	somehow bubbled back up to being active. It has the core idea, that
	a single pointer LEX.P is most of whats needed, and can be kept
	in a register, with a lot of inlining.

	I also have a second theory, which is an alternative to YACC,
	(this will never happen), and am manually generating code, that
	it might somehow generate. The idea would be to detect the
	maximum common prefix, draw a railroad, avoid ambiguity,
	and minimise backtracking. Dont wait up.
"""

menu_app = app_item( "pygtk_menu_app" )
menu_app.lang = "Python"
menu_app.desc_line = "A menu of runnable buttons"
menu_app.desc_text = """
	This is an initial scratch at RunOnAsIn,
	but thinking about it, C++ would be better.
"""

tests = app_item( "tests" )
tests.lang = "C++"
tests.desc_line = "test cases"
tests.desc_text = """
	Ever had an impossible compiler error?

	Creating test cases takes time, so why throw them away?
"""

lib_sud = app_item( "lib_sudoku" )
lib_sud.lang = "C++"
lib_sud.desc_line = "sudoku solver kit"
lib_sud.desc_text = """
	This is an early starting point.
	It manages 5000 solutions per seconds. It needs libs_apps
	It currently searches for "numbers for a square", later it will
	search for "squares for a number", then domino levels
	(puzzle creation) ((Not really a lib/kit))
"""


if 1:
	YearZone = app_item( "YearZone" )
	YearZone.lang = "C++"
	YearZone.desc_line = "cached date+time to/from int convertion "
	YearZone.desc_text = """
		This is a pre-prototype to convert time_t (signed int) to/from date/time
	
		The standard libc time functions are frankly awful.
	
		The libc functions are still used to find the edge values,
		where "summer-time" starts and ends, and the year starts,
		but after that, (which can be cached, possibly on disk or code)
		convertions should be much faster for values in the same year.
	
		This prototype is pre-early beta, but does NOT have a problem with
		2004-01-10 causing overflow on t2 = (t1+t3)/2
		
	"""

