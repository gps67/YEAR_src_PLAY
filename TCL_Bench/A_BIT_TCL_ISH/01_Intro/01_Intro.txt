
.S2 {
 .HDR {Intro}
 .P {
 	Tcl is a scripted language, with a clean but confused syntax.

	Like bash it looks like lines of words

		.CODE cmd arg1 arg2 
	
	Like bash and BASIC, variables use $var

		.CODE $b

	Unlike bash and C, you cant use {a=$b} you must use {set a $b}.
	That is interpretad as a command {set} with 2 arguments {a} and {$b}

		.CODE set a $b

	Each word does NOT need "quotes", so "tmp" can be written as tmp
	Sometimes this can make it quite clean, but dont worry, there is
	still proper punctuation to worry about

		.code set dirname tmp

	Unlike bash, it is quite easy to work with spaces within filenames.
	They do need "quotes" on the way in, but after that $filename
	and "$filename" are almost identical

		.CODE {
			set progname prog.exe
			set dirname "program files"
			set pathname /$dirname/$progname
			# nb TCL provides platform independent funcs for /
		}
	
	Like bash comments are lines that start with #

	Unlike bash, any statement on the left must be closed with ;#
	This is mildly annoying, but you will get used to it

	One Tcl magic ingredient, is how it uses {braces}. They are a bit like
	bashs 'single quotes', in that what is inside has the minimum of
	processing (yet), but they quickly look like C-block-braces.

		Basically a single {word} can actually be {multi-line-block}
		held as a single word. This allows blocks of code, to be there
		as a single word item, all on the 1 line.

	.code {
		if { $a < $b } {
			# lines
			# of
			# code 
			# here
		} else {
			# lines
			# of
			# code 
			# here
		}
	}

	One strange-ness is how it uses [code] where bash uses `code`

		On the on hand this is like {code in braces} 

		but on the other hand it is NOT like C array[idx]

		Like `bash backquotes` or $((bash eval))
		you have to use it a lot

		.code {
			set width 10
			set height 20
			set area [expr $width * $height]
		}
	
	A VERY STRANGE thing is that there are more than one parse styles.
	It is very confusing until you realise it, but {lines_of_code}
	use one parser and if {CONDITION} uses a different parser.
	Quoted list data uses yet another (you lose newlines)

	When you use {quoting braces} the text gets parsed twice.
	The first time, the text is NOT parsed, because that is how
	{braces} is parsed. The text result is passed as an argv parameter
	to the "if" command, which then chooses to do it's own parse (eval).

	.code if {condition} {code_one} else {code_two}

	If you forget to quote the {condition} or {code}, that is expanded
	before the "if" command is called, and passed as parameter text.

	All the standard if while foreach ... functions can be replaced by
	your own user defined ones (this can confuse security), and then your
	code, like the original, would need to expand $VAR in the callers
	context. For an easy life, always use {brace_quoting} and the result 
	is what you expect, but you can choose not to, and the text will be
	expanded twice. 

	There is a builtin compiler (to tcl byte code) which does that
	analysis, and retains the logic of what it found, for the next call.
	It "upgrades" the text values in-situ, which it can do, if {quoted},
	but might not be able to, is not the same quoted {program text}
	every time.

	.code while $still_looking { ... ; set still_looking 0; ... }

		This will expand $still_looking once.
		If it is true, it will loop forever.

	.code while {$still_looking} { ... ; set still_looking 0; ... }

		This is what you want.
		It expands $still_looking every loop
	
	The mechanisms for evaluating variables and code, in the parent
	callers context, is very useful. see upvar 

	There is a third evaluation style, EXPR CODE and now DATA
	It is very similar, and again it is the called function that
	does NOT do an extra eval on the DATA, but chooses to see EOLN
	as just another GAP between WORDS. CODE sees LINES_of_WORDS

	CODE uses LINES of WORDS

		where LINE of WORDS is COMMAND ARG ARG ARG
	
	EXPR uses tightly parsed words

	.code	if { $a < $b } {then_code} {else_code}

	DATA list uses WORDS 

	.code {
		set mylist {
			your
			word list
			here
		}
	}

	That produces 1 list of 4 words, this produces 3 words,
	where the middle word, is itself {TEXT} that will prod

	.code {
		set mylist {
			your
			{ word list }
			here
		}
	}

		actually that sets mylist to the text {...},
		but as soon as you lappend it is interpreted as WORDS.
	
	The outer {braces} are always processed by the callers parser

 }



}
