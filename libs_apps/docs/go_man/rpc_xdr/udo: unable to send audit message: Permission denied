RPC(3)                     Linux Programmer's Manual                    RPC(3)

NNAAMMEE
       rpc - library routines for remote procedure calls

SSYYNNOOPPSSIISS AANNDD DDEESSCCRRIIPPTTIIOONN
       These  routines  allow  C programs to make procedure calls on other ma‐
       chines across the network.  First, the client calls a procedure to send
       a  data  packet  to the server.  Upon receipt of the packet, the server
       calls a dispatch routine to perform the  requested  service,  and  then
       sends back a reply.  Finally, the procedure call returns to the client.

       To take use of these routines, include the header file _<_r_p_c_/_r_p_c_._h_>.

       The prototypes below make use of the following types:

           ttyyppeeddeeff iinntt _b_o_o_l___t;;

           ttyyppeeddeeff bbooooll__tt ((**_x_d_r_p_r_o_c___t)) ((XXDDRR **,, vvooiidd **,, ......));;

           ttyyppeeddeeff bbooooll__tt ((**_r_e_s_u_l_t_p_r_o_c___t)) ((ccaaddddrr__tt _r_e_s_p,,
                                           ssttrruucctt ssoocckkaaddddrr__iinn **_r_a_d_d_r));;

       See the header files for the declarations of the _A_U_T_H, _C_L_I_E_N_T, _S_V_C_X_P_R_T,
       and _X_D_R types.

       vvooiidd aauutthh__ddeessttrrooyy((AAUUTTHH **_a_u_t_h));;

              A macro that destroys the authentication information  associated
              with _a_u_t_h.  Destruction usually involves deallocation of private
              data structures.  The use of _a_u_t_h  is  undefined  after  calling
              aauutthh__ddeessttrrooyy().

       AAUUTTHH **aauutthhnnoonnee__ccrreeaattee((vvooiidd));;

              Create  and  return  an  RPC  authentication  handle that passes
              nonusable authentication information with each remote  procedure
              call.  This is the default authentication used by RPC.

       AAUUTTHH **aauutthhuunniixx__ccrreeaattee((cchhaarr **_h_o_s_t,, iinntt _u_i_d,, iinntt _g_i_d,,
                             iinntt _l_e_n,, iinntt **_a_u_p___g_i_d_s));;

              Create and return an RPC authentication handle that contains au‐
              thentication information.  The parameter _h_o_s_t is the name of the
              machine  on which the information was created; _u_i_d is the user's
              user ID; _g_i_d is the user's current group ID;  _l_e_n  and  _a_u_p___g_i_d_s
              refer  to  a  counted array of groups to which the user belongs.
              It is easy to impersonate a user.

       AAUUTTHH **aauutthhuunniixx__ccrreeaattee__ddeeffaauulltt((vvooiidd));;

              Calls aauutthhuunniixx__ccrreeaattee() with the appropriate parameters.

       iinntt ccaallllrrppcc((cchhaarr **_h_o_s_t,, uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,,
                   uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,, uunnssiiggnneedd lloonngg _p_r_o_c_n_u_m,,
                   xxddrrpprroocc__tt _i_n_p_r_o_c,, cchhaarr **_i_n,,
                   xxddrrpprroocc__tt _o_u_t_p_r_o_c,, cchhaarr **_o_u_t));;

              Call the remote procedure associated with _p_r_o_g_n_u_m, _v_e_r_s_n_u_m,  and
              _p_r_o_c_n_u_m  on  the machine, _h_o_s_t.  The parameter _i_n is the address
              of the procedure's argument(s), and _o_u_t is the address of  where
              to place the result(s); _i_n_p_r_o_c is used to encode the procedure's
              parameters, and _o_u_t_p_r_o_c is used to decode  the  procedure's  re‐
              sults.   This  routine returns zero if it succeeds, or the value
              of eennuumm ccllnntt__ssttaatt cast to an integer if it fails.   The  routine
              ccllnntt__ppeerrrrnnoo()  is  handy  for  translating failure statuses into
              messages.

              Warning: calling remote procedures with this routine uses UDP/IP
              as  a  transport; see ccllnnttuuddpp__ccrreeaattee() for restrictions.  You do
              not have control of timeouts or authentication using  this  rou‐
              tine.

       eennuumm ccllnntt__ssttaatt ccllnntt__bbrrooaaddccaasstt((uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,,
                            uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,, uunnssiiggnneedd lloonngg _p_r_o_c_n_u_m,,
                            xxddrrpprroocc__tt _i_n_p_r_o_c,, cchhaarr **_i_n,,
                            xxddrrpprroocc__tt _o_u_t_p_r_o_c,, cchhaarr **_o_u_t,,
                            rreessuullttpprroocc__tt _e_a_c_h_r_e_s_u_l_t));;

              Like  ccaallllrrppcc(), except the call message is broadcast to all lo‐
              cally connected broadcast nets.  Each time  it  receives  a  re‐
              sponse, this routine calls eeaacchhrreessuulltt(), whose form is:

                  eeaacchhrreessuulltt((cchhaarr **_o_u_t,, ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r));;

              where  _o_u_t is the same as _o_u_t passed to ccllnntt__bbrrooaaddccaasstt(), except
              that the remote procedure's output is decoded there; _a_d_d_r points
              to the address of the machine that sent the results.  If eeaacchhrree‐‐
              ssuulltt() returns zero, ccllnntt__bbrrooaaddccaasstt() waits  for  more  replies;
              otherwise it returns with appropriate status.

              Warning:  broadcast  sockets  are limited in size to the maximum
              transfer unit of the data link.  For  ethernet,  this  value  is
              1500 bytes.

       eennuumm ccllnntt__ssttaatt ccllnntt__ccaallll((CCLLIIEENNTT **_c_l_n_t,, uunnssiiggnneedd lloonngg _p_r_o_c_n_u_m,,
                           xxddrrpprroocc__tt _i_n_p_r_o_c,, cchhaarr **_i_n,,
                           xxddrrpprroocc__tt _o_u_t_p_r_o_c,, cchhaarr **_o_u_t,,
                           ssttrruucctt ttiimmeevvaall _t_o_u_t));;

              A  macro that calls the remote procedure _p_r_o_c_n_u_m associated with
              the client handle, _c_l_n_t, which is obtained with  an  RPC  client
              creation routine such as ccllnntt__ccrreeaattee().  The parameter _i_n is the
              address of the procedure's argument(s), and _o_u_t is  the  address
              of  where  to  place the result(s); _i_n_p_r_o_c is used to encode the
              procedure's parameters, and _o_u_t_p_r_o_c is used to decode the proce‐
              dure's  results;  _t_o_u_t  is  the time allowed for results to come
              back.

       ccllnntt__ddeessttrrooyy((CCLLIIEENNTT **_c_l_n_t));;

              A macro that destroys the client's RPC handle.  Destruction usu‐
              ally involves deallocation of private data structures, including
              _c_l_n_t itself.  Use of _c_l_n_t is undefined  after  calling  ccllnntt__ddee‐‐
              ssttrrooyy().   If  the  RPC library opened the associated socket, it
              will close it also.  Otherwise, the socket remains open.

       CCLLIIEENNTT **ccllnntt__ccrreeaattee((cchhaarr **_h_o_s_t,, uunnssiiggnneedd lloonngg _p_r_o_g,,
                           uunnssiiggnneedd lloonngg _v_e_r_s,, cchhaarr **_p_r_o_t_o));;

              Generic client creation routine.  _h_o_s_t identifies  the  name  of
              the  remote  host  where the server is located.  _p_r_o_t_o indicates
              which kind of transport protocol to  use.   The  currently  sup‐
              ported values for this field are “udp” and “tcp”.  Default time‐
              outs are set, but can be modified using ccllnntt__ccoonnttrrooll().

              Warning: using UDP has its shortcomings.   Since  UDP-based  RPC
              messages  can  hold  only  up  to 8 Kbytes of encoded data, this
              transport cannot be used for procedures that  take  large  argu‐
              ments or return huge results.

       bbooooll__tt ccllnntt__ccoonnttrrooll((CCLLIIEENNTT **_c_l,, iinntt _r_e_q,, cchhaarr **_i_n_f_o));;

              A  macro  used to change or retrieve various information about a
              client object.  _r_e_q indicates the type of operation, and _i_n_f_o is
              a  pointer  to  the information.  For both UDP and TCP, the sup‐
              ported values of _r_e_q and their argument types and what  they  do
              are:

                  CCLLSSEETT__TTIIMMEEOOUUTT  _s_t_r_u_c_t _t_i_m_e_v_a_l // set total timeout
                  CCLLGGEETT__TTIIMMEEOOUUTT  _s_t_r_u_c_t _t_i_m_e_v_a_l // get total timeout

              Note:  if  you set the timeout using ccllnntt__ccoonnttrrooll(), the timeout
              parameter passed to ccllnntt__ccaallll() will be ignored  in  all  future
              calls.

                  CCLLGGEETT__SSEERRVVEERR__AADDDDRR  _s_t_r_u_c_t _s_o_c_k_a_d_d_r___i_n  // get server's address

              The following operations are valid for UDP only:

                  CCLLSSEETT__RREETTRRYY__TTIIMMEEOOUUTT  _s_t_r_u_c_t _t_i_m_e_v_a_l // set the retry timeout
                  CCLLGGEETT__RREETTRRYY__TTIIMMEEOOUUTT  _s_t_r_u_c_t _t_i_m_e_v_a_l // get the retry timeout

              The  retry  timeout  is  the  time  that "UDP RPC" waits for the
              server to reply before retransmitting the request.

       ccllnntt__ffrreeeerreess((CCLLIIEENNTT ** _c_l_n_t,, xxddrrpprroocc__tt _o_u_t_p_r_o_c,, cchhaarr **_o_u_t));;

              A macro that frees any data allocated by the RPC/XDR system when
              it decoded the results of an RPC call.  The parameter _o_u_t is the
              address of the results, and _o_u_t_p_r_o_c is the XDR routine  describ‐
              ing  the  results.  This routine returns one if the results were
              successfully freed, and zero otherwise.

       vvooiidd ccllnntt__ggeetteerrrr((CCLLIIEENNTT **_c_l_n_t,, ssttrruucctt rrppcc__eerrrr **_e_r_r_p));;

              A macro that copies the error structure out of the client handle
              to the structure at address _e_r_r_p.

       vvooiidd ccllnntt__ppccrreeaatteeeerrrroorr((cchhaarr **_s));;

              Print  a  message  to standard error indicating why a client RPC
              handle could not be created.   The  message  is  prepended  with
              string  _s  and a colon.  Used when a ccllnntt__ccrreeaattee(), ccllnnttrraaww__ccrree‐‐
              aattee(), ccllnnttttccpp__ccrreeaattee(), or ccllnnttuuddpp__ccrreeaattee() call fails.

       vvooiidd ccllnntt__ppeerrrrnnoo((eennuumm ccllnntt__ssttaatt _s_t_a_t));;

              Print a message to standard error corresponding to the condition
              indicated by _s_t_a_t.  Used after ccaallllrrppcc().

       ccllnntt__ppeerrrroorr((CCLLIIEENNTT **_c_l_n_t,, cchhaarr **_s));;

              Print  a  message  to  standard error indicating why an RPC call
              failed; _c_l_n_t is the handle used to do the call.  The message  is
              prepended with string _s and a colon.  Used after ccllnntt__ccaallll().

       cchhaarr **ccllnntt__ssppccrreeaatteeeerrrroorr((cchhaarr **_s));;

              Like  ccllnntt__ppccrreeaatteeeerrrroorr(),  except  that it returns a string in‐
              stead of printing to the standard error.

              Bugs: returns pointer to static data that is overwritten on each
              call.

       cchhaarr **ccllnntt__ssppeerrrrnnoo((eennuumm ccllnntt__ssttaatt _s_t_a_t));;

              Take the same arguments as ccllnntt__ppeerrrrnnoo(), but instead of sending
              a message to the standard  error  indicating  why  an  RPC  call
              failed, return a pointer to a string which contains the message.
              The string ends with a NEWLINE.

              ccllnntt__ssppeerrrrnnoo() is used instead of ccllnntt__ppeerrrrnnoo() if  the  program
              does not have a standard error (as a program running as a server
              quite likely does not), or if the programmer does not  want  the
              message to be output with pprriinnttff(3), or if a message format dif‐
              ferent than that supported  by  ccllnntt__ppeerrrrnnoo()  is  to  be  used.
              Note: unlike ccllnntt__ssppeerrrroorr() and ccllnntt__ssppccrreeaatteeeerrrroorr(), ccllnntt__ssppeerr‐‐
              rrnnoo() returns pointer to static data, but the  result  will  not
              get overwritten on each call.

       cchhaarr **ccllnntt__ssppeerrrroorr((CCLLIIEENNTT **_r_p_c_h,, cchhaarr **_s));;

              Like ccllnntt__ppeerrrroorr(), except that (like ccllnntt__ssppeerrrrnnoo()) it returns
              a string instead of printing to standard error.

              Bugs: returns pointer to static data that is overwritten on each
              call.

       CCLLIIEENNTT **ccllnnttrraaww__ccrreeaattee((uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m));;

              This  routine  creates  a  toy RPC client for the remote program
              _p_r_o_g_n_u_m, version _v_e_r_s_n_u_m.  The transport used to  pass  messages
              to the service is actually a buffer within the process's address
              space, so the corresponding RPC server should live in  the  same
              address  space;  see ssvvccrraaww__ccrreeaattee().  This allows simulation of
              RPC and acquisition of RPC overheads, such as round trip  times,
              without  any  kernel interference.  This routine returns NULL if
              it fails.

       CCLLIIEENNTT **ccllnnttttccpp__ccrreeaattee((ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r,,
                       uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                       iinntt **_s_o_c_k_p,, uunnssiiggnneedd iinntt _s_e_n_d_s_z,, uunnssiiggnneedd iinntt _r_e_c_v_s_z));;

              This routine creates  an  RPC  client  for  the  remote  program
              _p_r_o_g_n_u_m, version _v_e_r_s_n_u_m; the client uses TCP/IP as a transport.
              The remote program is located at  Internet  address  _*_a_d_d_r.   If
              _a_d_d_r_-_>_s_i_n___p_o_r_t  is  zero, then it is set to the actual port that
              the remote program is listening on (the remote  ppoorrttmmaapp  service
              is  consulted  for  this information).  The parameter _s_o_c_k_p is a
              socket; if it is RRPPCC__AANNYYSSOOCCKK, then this routine opens a new  one
              and sets _s_o_c_k_p.  Since TCP-based RPC uses buffered I/O, the user
              may specify the size of the send and receive  buffers  with  the
              parameters _s_e_n_d_s_z and _r_e_c_v_s_z; values of zero choose suitable de‐
              faults.  This routine returns NULL if it fails.

       CCLLIIEENNTT **ccllnnttuuddpp__ccrreeaattee((ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r,,
                       uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                       ssttrruucctt ttiimmeevvaall _w_a_i_t,, iinntt **_s_o_c_k_p));;

              This routine creates  an  RPC  client  for  the  remote  program
              _p_r_o_g_n_u_m, version _v_e_r_s_n_u_m; the client uses use UDP/IP as a trans‐
              port.  The remote program is located at Internet  address  _a_d_d_r.
              If  _a_d_d_r_-_>_s_i_n___p_o_r_t  is  zero, then it is set to actual port that
              the remote program is listening on (the remote  ppoorrttmmaapp  service
              is  consulted  for  this information).  The parameter _s_o_c_k_p is a
              socket; if it is RRPPCC__AANNYYSSOOCCKK, then this routine opens a new  one
              and  sets  _s_o_c_k_p.  The UDP transport resends the call message in
              intervals of _w_a_i_t time until a response is received or until the
              call  times  out.   The  total  time for the call to time out is
              specified by ccllnntt__ccaallll().

              Warning: since UDP-based RPC messages can  hold  only  up  to  8
              Kbytes of encoded data, this transport cannot be used for proce‐
              dures that take large arguments or return huge results.

       CCLLIIEENNTT **ccllnnttuuddpp__bbuuffccrreeaattee((ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r,,
                   uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                   ssttrruucctt ttiimmeevvaall _w_a_i_t,, iinntt **_s_o_c_k_p,,
                   uunnssiiggnneedd iinntt _s_e_n_d_s_i_z_e,, uunnssiiggnneedd iinntt _r_e_c_o_s_i_z_e));;

              This routine creates  an  RPC  client  for  the  remote  program
              _p_r_o_g_n_u_m,  on _v_e_r_s_n_u_m; the client uses use UDP/IP as a transport.
              The remote program is located  at  Internet  address  _a_d_d_r.   If
              _a_d_d_r_-_>_s_i_n___p_o_r_t  is  zero, then it is set to actual port that the
              remote program is listening on (the remote  ppoorrttmmaapp  service  is
              consulted  for  this  information).   The  parameter  _s_o_c_k_p is a
              socket; if it is RRPPCC__AANNYYSSOOCCKK, then this routine opens a new  one
              and  sets  _s_o_c_k_p.  The UDP transport resends the call message in
              intervals of _w_a_i_t time until a response is received or until the
              call  times  out.   The  total  time for the call to time out is
              specified by ccllnntt__ccaallll().

              This allows the user to specify  the  maximum  packet  size  for
              sending and receiving UDP-based RPC messages.

       vvooiidd ggeett__mmyyaaddddrreessss((ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r));;

              Stuff  the  machine's  IP address into _*_a_d_d_r, without consulting
              the library routines that deal with _/_e_t_c_/_h_o_s_t_s.  The port number
              is always set to hhttoonnss((PPMMAAPPPPOORRTT)).

       ssttrruucctt ppmmaapplliisstt **ppmmaapp__ggeettmmaappss((ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r));;

              A user interface to the ppoorrttmmaapp service, which returns a list of
              the current RPC program-to-port mappings on the host located  at
              IP  address  _*_a_d_d_r.   This routine can return NULL.  The command
              _r_p_c_i_n_f_o _-_p uses this routine.

       uunnssiiggnneedd sshhoorrtt ppmmaapp__ggeettppoorrtt((ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r,,
                           uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                           uunnssiiggnneedd iinntt _p_r_o_t_o_c_o_l));;

              A user interface to the ppoorrttmmaapp service, which returns the  port
              number  on  which  waits  a service that supports program number
              _p_r_o_g_n_u_m, version _v_e_r_s_n_u_m, and speaks the transport protocol  as‐
              sociated  with  _p_r_o_t_o_c_o_l.   The value of _p_r_o_t_o_c_o_l is most likely
              IIPPPPRROOTTOO__UUDDPP or IIPPPPRROOTTOO__TTCCPP.  A return value of zero  means  that
              the mapping does not exist or that the RPC system failed to con‐
              tact the remote ppoorrttmmaapp service.  In the latter case, the global
              variable _r_p_c___c_r_e_a_t_e_e_r_r contains the RPC status.

       eennuumm ccllnntt__ssttaatt ppmmaapp__rrmmttccaallll((ssttrruucctt ssoocckkaaddddrr__iinn **_a_d_d_r,,
                           uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                           uunnssiiggnneedd lloonngg _p_r_o_c_n_u_m,,
                           xxddrrpprroocc__tt _i_n_p_r_o_c,, cchhaarr **_i_n,,
                           xxddrrpprroocc__tt _o_u_t_p_r_o_c,, cchhaarr **_o_u_t,,
                           ssttrruucctt ttiimmeevvaall _t_o_u_t,, uunnssiiggnneedd lloonngg **_p_o_r_t_p));;

              A user interface to the ppoorrttmmaapp service, which instructs ppoorrttmmaapp
              on the host at IP address _*_a_d_d_r to make an RPC call on your  be‐
              half  to a procedure on that host.  The parameter _*_p_o_r_t_p will be
              modified to the program's port number if the procedure succeeds.
              The  definitions  of other parameters are discussed in ccaallllrrppcc()
              and ccllnntt__ccaallll().  This procedure should be used for a “ping” and
              nothing else.  See also ccllnntt__bbrrooaaddccaasstt().

       bbooooll__tt ppmmaapp__sseett((uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                       uunnssiiggnneedd iinntt _p_r_o_t_o_c_o_l,, uunnssiiggnneedd sshhoorrtt _p_o_r_t));;

              A  user  interface  to  the ppoorrttmmaapp service, which establishes a
              mapping between the triple [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,_p_r_o_t_o_c_o_l]  and  _p_o_r_t
              on the machine's ppoorrttmmaapp service.  The value of _p_r_o_t_o_c_o_l is most
              likely IIPPPPRROOTTOO__UUDDPP or IIPPPPRROOTTOO__TTCCPP.  This routine returns one  if
              it  succeeds,  zero otherwise.  Automatically done by ssvvcc__rreeggiiss‐‐
              tteerr().

       bbooooll__tt ppmmaapp__uunnsseett((uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m));;

              A user interface to the ppoorrttmmaapp service, which destroys all map‐
              ping between the triple [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,_*] and ppoorrttss on the ma‐
              chine's ppoorrttmmaapp service.  This routine returns one  if  it  suc‐
              ceeds, zero otherwise.

       iinntt rreeggiisstteerrrrppcc((uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                       uunnssiiggnneedd lloonngg _p_r_o_c_n_u_m,, cchhaarr **((**_p_r_o_c_n_a_m_e))((cchhaarr **)),,
                       xxddrrpprroocc__tt _i_n_p_r_o_c,, xxddrrpprroocc__tt _o_u_t_p_r_o_c));;

              Register  procedure _p_r_o_c_n_a_m_e with the RPC service package.  If a
              request arrives for program _p_r_o_g_n_u_m, version _v_e_r_s_n_u_m, and proce‐
              dure  _p_r_o_c_n_u_m,  _p_r_o_c_n_a_m_e is called with a pointer to its parame‐
              ter(s); _p_r_o_c_n_a_m_e should return  a  pointer  to  its  static  re‐
              sult(s);  _i_n_p_r_o_c  is used to decode the parameters while _o_u_t_p_r_o_c
              is used to encode the results.  This routine returns zero if the
              registration succeeded, -1 otherwise.

              Warning:  remote procedures registered in this form are accessed
              using the UDP/IP transport;  see  ssvvccuuddpp__ccrreeaattee()  for  restric‐
              tions.

       ssttrruucctt rrppcc__ccrreeaatteeeerrrr _r_p_c___c_r_e_a_t_e_e_r_r;;

              A  global variable whose value is set by any RPC client creation
              routine that does not succeed.  Use the routine  ccllnntt__ppccrreeaatteeeerr‐‐
              rroorr() to print the reason why.

       vvooiidd ssvvcc__ddeessttrrooyy((SSVVCCXXPPRRTT **_x_p_r_t));;

              A  macro  that  destroys the RPC service transport handle, _x_p_r_t.
              Destruction usually involves deallocation of private data struc‐
              tures,  including  _x_p_r_t  itself.  Use of _x_p_r_t is undefined after
              calling this routine.

       ffdd__sseett _s_v_c___f_d_s_e_t;;

              A global variable reflecting the RPC service  side's  read  file
              descriptor  bit  mask;  it is suitable as a parameter to the ssee‐‐
              lleecctt(2) system call.  This is of interest only if a service  im‐
              plementor  does their own asynchronous event processing, instead
              of calling ssvvcc__rruunn().  This variable is read-only (do  not  pass
              its  address  to  sseelleecctt(2)!),  yet it may change after calls to
              ssvvcc__ggeettrreeqqsseett() or any creation routines.

       iinntt _s_v_c___f_d_s;;

              Similar to ssvvcc__ffddsseett, but limited to 32 file descriptors.   This
              interface is obsoleted by ssvvcc__ffddsseett.

       ssvvcc__ffrreeeeaarrggss((SSVVCCXXPPRRTT **_x_p_r_t,, xxddrrpprroocc__tt _i_n_p_r_o_c,, cchhaarr **_i_n));;

              A macro that frees any data allocated by the RPC/XDR system when
              it  decoded  the  arguments  to  a   service   procedure   using
              ssvvcc__ggeettaarrggss().   This routine returns 1 if the results were suc‐
              cessfully freed, and zero otherwise.

       ssvvcc__ggeettaarrggss((SSVVCCXXPPRRTT **_x_p_r_t,, xxddrrpprroocc__tt _i_n_p_r_o_c,, cchhaarr **_i_n));;

              A macro that decodes the arguments of an RPC request  associated
              with  the  RPC service transport handle, _x_p_r_t.  The parameter _i_n
              is the address where the arguments will be placed; _i_n_p_r_o_c is the
              XDR  routine used to decode the arguments.  This routine returns
              one if decoding succeeds, and zero otherwise.

       ssttrruucctt ssoocckkaaddddrr__iinn **ssvvcc__ggeettccaalllleerr((SSVVCCXXPPRRTT **_x_p_r_t));;

              The approved way of getting the network address of the caller of
              a  procedure  associated  with the RPC service transport handle,
              _x_p_r_t.

       vvooiidd ssvvcc__ggeettrreeqqsseett((ffdd__sseett **_r_d_f_d_s));;

              This routine is of interest only if a service  implementor  does
              not  call  ssvvcc__rruunn(), but instead implements custom asynchronous
              event processing.  It is called when the sseelleecctt(2)  system  call
              has  determined  that  an  RPC  request  has arrived on some RPC
              socket(s); _r_d_f_d_s is the resultant read file descriptor bit mask.
              The  routine  returns when all sockets associated with the value
              of _r_d_f_d_s have been serviced.

       vvooiidd ssvvcc__ggeettrreeqq((iinntt _r_d_f_d_s));;

              Similar to ssvvcc__ggeettrreeqqsseett(), but limited to 32 file  descriptors.
              This interface is obsoleted by ssvvcc__ggeettrreeqqsseett().

       bbooooll__tt ssvvcc__rreeggiisstteerr((SSVVCCXXPPRRTT **_x_p_r_t,, uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,,
                           uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m,,
                           vvooiidd ((**_d_i_s_p_a_t_c_h))((ssvvcc__rreeqq **,, SSVVCCXXPPRRTT **)),,
                           uunnssiiggnneedd lloonngg _p_r_o_t_o_c_o_l));;

              Associates  _p_r_o_g_n_u_m and _v_e_r_s_n_u_m with the service dispatch proce‐
              dure, _d_i_s_p_a_t_c_h.  If _p_r_o_t_o_c_o_l is zero, the service is not  regis‐
              tered  with the ppoorrttmmaapp service.  If _p_r_o_t_o_c_o_l is nonzero, then a
              mapping   of   the    triple    [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,_p_r_o_t_o_c_o_l]    to
              _x_p_r_t_-_>_x_p___p_o_r_t  is  established  with  the  local ppoorrttmmaapp service
              (generally _p_r_o_t_o_c_o_l is zero, IIPPPPRROOTTOO__UUDDPP or  IIPPPPRROOTTOO__TTCCPP).   The
              procedure _d_i_s_p_a_t_c_h has the following form:

                  dispatch(struct svc_req *request, SVCXPRT *xprt);

              The  ssvvcc__rreeggiisstteerr() routine returns one if it succeeds, and zero
              otherwise.

       vvooiidd ssvvcc__rruunn((vvooiidd));;

              This routine never returns.  It waits for RPC  requests  to  ar‐
              rive,  and calls the appropriate service procedure using ssvvcc__ggee‐‐
              ttrreeqq() when one arrives.  This procedure is usually waiting  for
              a sseelleecctt(2) system call to return.

       bbooooll__tt ssvvcc__sseennddrreeppllyy((SSVVCCXXPPRRTT **_x_p_r_t,, xxddrrpprroocc__tt _o_u_t_p_r_o_c,, cchhaarr **_o_u_t));;

              Called  by an RPC service's dispatch routine to send the results
              of a remote procedure call.  The parameter _x_p_r_t is the request's
              associated transport handle; _o_u_t_p_r_o_c is the XDR routine which is
              used to encode the results; and _o_u_t is the address  of  the  re‐
              sults.  This routine returns one if it succeeds, zero otherwise.

       vvooiidd ssvvcc__uunnrreeggiisstteerr((uunnssiiggnneedd lloonngg _p_r_o_g_n_u_m,, uunnssiiggnneedd lloonngg _v_e_r_s_n_u_m));;

              Remove  all  mapping of the double [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m] to dispatch
              routines, and of the triple [_p_r_o_g_n_u_m,_v_e_r_s_n_u_m,_*] to port number.

       vvooiidd ssvvcceerrrr__aauutthh((SSVVCCXXPPRRTT **_x_p_r_t,, eennuumm aauutthh__ssttaatt _w_h_y));;

              Called by a service dispatch routine that refuses to  perform  a
              remote procedure call due to an authentication error.

       vvooiidd ssvvcceerrrr__ddeeccooddee((SSVVCCXXPPRRTT **_x_p_r_t));;

              Called  by  a  service dispatch routine that cannot successfully
              decode its parameters.  See also ssvvcc__ggeettaarrggss().

       vvooiidd ssvvcceerrrr__nnoopprroocc((SSVVCCXXPPRRTT **_x_p_r_t));;

              Called by a service dispatch routine that does not implement the
              procedure number that the caller requests.

       vvooiidd ssvvcceerrrr__nnoopprroogg((SSVVCCXXPPRRTT **_x_p_r_t));;

              Called  when  the desired program is not registered with the RPC
              package.  Service implementors usually do not need this routine.

       vvooiidd ssvvcceerrrr__pprrooggvveerrss((SSVVCCXXPPRRTT **_x_p_r_t));;

              Called when the desired version of a program is  not  registered
              with  the RPC package.  Service implementors usually do not need
              this routine.

       vvooiidd ssvvcceerrrr__ssyysstteemmeerrrr((SSVVCCXXPPRRTT **_x_p_r_t));;

              Called by a service dispatch routine when it  detects  a  system
              error not covered by any particular protocol.  For example, if a
              service can no longer allocate storage, it may  call  this  rou‐
              tine.

       vvooiidd ssvvcceerrrr__wweeaakkaauutthh((SSVVCCXXPPRRTT **_x_p_r_t));;

              Called  by  a service dispatch routine that refuses to perform a
              remote procedure call due to insufficient authentication parame‐
              ters.  The routine calls ssvvcceerrrr__aauutthh((xxpprrtt,, AAUUTTHH__TTOOOOWWEEAAKK)).

       SSVVCCXXPPRRTT **ssvvccffdd__ccrreeaattee((iinntt _f_d,, uunnssiiggnneedd iinntt _s_e_n_d_s_i_z_e,,
                             uunnssiiggnneedd iinntt _r_e_c_v_s_i_z_e));;

              Create a service on top of any open file descriptor.  Typically,
              this file descriptor is a connected socket for a stream protocol
              such  as TCP.  _s_e_n_d_s_i_z_e and _r_e_c_v_s_i_z_e indicate sizes for the send
              and receive buffers.  If they are zero, a reasonable default  is
              chosen.

       SSVVCCXXPPRRTT **ssvvccrraaww__ccrreeaattee((vvooiidd));;

              This  routine  creates  a toy RPC service transport, to which it
              returns a pointer.  The transport is really a buffer within  the
              process's  address space, so the corresponding RPC client should
              live in the same address space; see ccllnnttrraaww__ccrreeaattee().  This rou‐
              tine  allows  simulation of RPC and acquisition of RPC overheads
              (such as round trip times),  without  any  kernel  interference.
              This routine returns NULL if it fails.

       SSVVCCXXPPRRTT **ssvvccttccpp__ccrreeaattee((iinntt _s_o_c_k,, uunnssiiggnneedd iinntt _s_e_n_d___b_u_f___s_i_z_e,,
                              uunnssiiggnneedd iinntt _r_e_c_v___b_u_f___s_i_z_e));;

              This  routine  creates  a TCP/IP-based RPC service transport, to
              which it returns a pointer.  The transport  is  associated  with
              the  socket  _s_o_c_k, which may be RRPPCC__AANNYYSSOOCCKK, in which case a new
              socket is created.  If the socket is not bound to  a  local  TCP
              port,  then  this  routine  binds it to an arbitrary port.  Upon
              completion, _x_p_r_t_-_>_x_p___s_o_c_k is the transport's socket  descriptor,
              and  _x_p_r_t_-_>_x_p___p_o_r_t is the transport's port number.  This routine
              returns NULL if it fails.  Since  TCP-based  RPC  uses  buffered
              I/O,  users  may  specify  the  size  of buffers; values of zero
              choose suitable defaults.

       SSVVCCXXPPRRTT **ssvvccuuddpp__bbuuffccrreeaattee((iinntt _s_o_c_k,, uunnssiiggnneedd iinntt _s_e_n_d_s_i_z_e,,
                                 uunnssiiggnneedd iinntt _r_e_c_o_s_i_z_e));;

              This routine creates a UDP/IP-based RPC  service  transport,  to
              which  it  returns  a pointer.  The transport is associated with
              the socket _s_o_c_k, which may be RRPPCC__AANNYYSSOOCCKK, in which case  a  new
              socket  is  created.   If the socket is not bound to a local UDP
              port, then this routine binds it to  an  arbitrary  port.   Upon
              completion,  _x_p_r_t_-_>_x_p___s_o_c_k is the transport's socket descriptor,
              and _x_p_r_t_-_>_x_p___p_o_r_t is the transport's port number.  This  routine
              returns NULL if it fails.

              This  allows  the  user  to  specify the maximum packet size for
              sending and receiving UDP-based RPC messages.

       SSVVCCXXPPRRTT **ssvvccuuddpp__ccrreeaattee((iinntt _s_o_c_k));;

              This call is equivalent to _s_v_c_u_d_p___b_u_f_c_r_e_a_t_e_(_s_o_c_k_,_S_Z_,_S_Z_) for some
              default size _S_Z.

       bbooooll__tt xxddrr__aacccceepptteedd__rreeppllyy((XXDDRR **_x_d_r_s,, ssttrruucctt aacccceepptteedd__rreeppllyy **_a_r));;

              Used  for  encoding  RPC reply messages.  This routine is useful
              for users who wish to generate RPC-style messages without  using
              the RPC package.

       bbooooll__tt xxddrr__aauutthhuunniixx__ppaarrmmss((XXDDRR **_x_d_r_s,, ssttrruucctt aauutthhuunniixx__ppaarrmmss **_a_u_p_p));;

              Used  for  describing  UNIX credentials.  This routine is useful
              for users who wish to generate these credentials  without  using
              the RPC authentication package.

       vvooiidd xxddrr__ccaallllhhddrr((XXDDRR **_x_d_r_s,, ssttrruucctt rrppcc__mmssgg **_c_h_d_r));;

              Used  for  describing RPC call header messages.  This routine is
              useful for users who wish to generate RPC-style messages without
              using the RPC package.

       bbooooll__tt xxddrr__ccaallllmmssgg((XXDDRR **_x_d_r_s,, ssttrruucctt rrppcc__mmssgg **_c_m_s_g));;

              Used  for  describing RPC call messages.  This routine is useful
              for users who wish to generate RPC-style messages without  using
              the RPC package.

       bbooooll__tt xxddrr__ooppaaqquuee__aauutthh((XXDDRR **_x_d_r_s,, ssttrruucctt ooppaaqquuee__aauutthh **_a_p));;

              Used  for  describing  RPC  authentication information messages.
              This routine is useful for users who wish to generate  RPC-style
              messages without using the RPC package.

       bbooooll__tt xxddrr__ppmmaapp((XXDDRR **_x_d_r_s,, ssttrruucctt ppmmaapp **_r_e_g_s));;

              Used  for  describing  parameters to various ppoorrttmmaapp procedures,
              externally.  This routine is useful for users who wish to gener‐
              ate these parameters without using the ppmmaapp interface.

       bbooooll__tt xxddrr__ppmmaapplliisstt((XXDDRR **_x_d_r_s,, ssttrruucctt ppmmaapplliisstt ****_r_p));;

              Used  for  describing a list of port mappings, externally.  This
              routine is useful for users who wish to generate  these  parame‐
              ters without using the ppmmaapp interface.

       bbooooll__tt xxddrr__rreejjeecctteedd__rreeppllyy((XXDDRR **_x_d_r_s,, ssttrruucctt rreejjeecctteedd__rreeppllyy **_r_r));;

              Used  for describing RPC reply messages.  This routine is useful
              for users who wish to generate RPC-style messages without  using
              the RPC package.

       bbooooll__tt xxddrr__rreeppllyymmssgg((XXDDRR **_x_d_r_s,, ssttrruucctt rrppcc__mmssgg **_r_m_s_g));;

              Used  for describing RPC reply messages.  This routine is useful
              for users who wish to generate RPC style messages without  using
              the RPC package.

       vvooiidd xxpprrtt__rreeggiisstteerr((SSVVCCXXPPRRTT **_x_p_r_t));;

              After  RPC  service  transport  handles are created, they should
              register themselves with the RPC service package.  This  routine
              modifies the global variable _s_v_c___f_d_s.  Service implementors usu‐
              ally do not need this routine.

       vvooiidd xxpprrtt__uunnrreeggiisstteerr((SSVVCCXXPPRRTT **_x_p_r_t));;

              Before an RPC service transport handle is destroyed,  it  should
              unregister  itself  with  the RPC service package.  This routine
              modifies the global variable _s_v_c___f_d_s.  Service implementors usu‐
              ally do not need this routine.

AATTTTRRIIBBUUTTEESS
       For  an  explanation  of  the  terms  used  in  this  section,  see aatt‐‐
       ttrriibbuutteess(7).

       ┌────────────────────────────────────┬───────────────┬─────────┐
       │IInntteerrffaaccee                           │ AAttttrriibbuuttee     │ VVaalluuee   │
       ├────────────────────────────────────┼───────────────┼─────────┤
       │aauutthh__ddeessttrrooyy(), aauutthhnnoonnee__ccrreeaattee(),  │ Thread safety │ MT-Safe │
       │aauutthhuunniixx__ccrreeaattee(),                  │               │         │
       │aauutthhuunniixx__ccrreeaattee__ddeeffaauulltt(),          │               │         │
       │ccaallllrrppcc(), ccllnntt__bbrrooaaddccaasstt(),        │               │         │
       │ccllnntt__ccaallll(), ccllnntt__ddeessttrrooyy(),        │               │         │
       │ccllnntt__ccrreeaattee(), ccllnntt__ccoonnttrrooll(),      │               │         │
       │ccllnntt__ffrreeeerreess(), ccllnntt__ggeetteerrrr(),      │               │         │
       │ccllnntt__ppccrreeaatteeeerrrroorr(), ccllnntt__ppeerrrrnnoo(), │               │         │
       │ccllnntt__ppeerrrroorr(),                      │               │         │
       │ccllnntt__ssppccrreeaatteeeerrrroorr(),               │               │         │
       │ccllnntt__ssppeerrrrnnoo(), ccllnntt__ssppeerrrroorr(),     │               │         │
       │ccllnnttrraaww__ccrreeaattee(), ccllnnttttccpp__ccrreeaattee(), │               │         │
       │ccllnnttuuddpp__ccrreeaattee(),                   │               │         │
       │ccllnnttuuddpp__bbuuffccrreeaattee(),                │               │         │
       │ggeett__mmyyaaddddrreessss(), ppmmaapp__ggeettmmaappss(),    │               │         │
       │ppmmaapp__ggeettppoorrtt(), ppmmaapp__rrmmttccaallll(),     │               │         │
       │ppmmaapp__sseett(), ppmmaapp__uunnsseett(),           │               │         │
       │rreeggiisstteerrrrppcc(), ssvvcc__ddeessttrrooyy(),       │               │         │
       │ssvvcc__ffrreeeeaarrggss(), ssvvcc__ggeettaarrggss(),      │               │         │
       │ssvvcc__ggeettccaalllleerr(), ssvvcc__ggeettrreeqqsseett(),   │               │         │
       │ssvvcc__ggeettrreeqq(), ssvvcc__rreeggiisstteerr(),       │               │         │
       │ssvvcc__rruunn(), ssvvcc__sseennddrreeppllyy(),         │               │         │
       │ssvvcc__uunnrreeggiisstteerr(), ssvvcceerrrr__aauutthh(),    │               │         │
       │ssvvcceerrrr__ddeeccooddee(), ssvvcceerrrr__nnoopprroocc(),   │               │         │
       │ssvvcceerrrr__nnoopprroogg(), ssvvcceerrrr__pprrooggvveerrss(), │               │         │
       │ssvvcceerrrr__ssyysstteemmeerrrr(),                 │               │         │
       │ssvvcceerrrr__wweeaakkaauutthh(),                  │               │         │
       │ssvvccffdd__ccrreeaattee(), ssvvccrraaww__ccrreeaattee(),    │               │         │
       │ssvvccttccpp__ccrreeaattee(),                    │               │         │
       │ssvvccuuddpp__bbuuffccrreeaattee(),                 │               │         │
       │ssvvccuuddpp__ccrreeaattee(), xxddrr__aacccceepptteedd__rree‐‐   │               │         │
       │ppllyy(),                              │               │         │
       │xxddrr__aauutthhuunniixx__ppaarrmmss(),               │               │         │
       │xxddrr__ccaallllhhddrr(),                      │               │         │
       │xxddrr__ccaallllmmssgg(), xxddrr__ooppaaqquuee__aauutthh(),   │               │         │
       │xxddrr__ppmmaapp(), xxddrr__ppmmaapplliisstt(),         │               │         │
       │xxddrr__rreejjeecctteedd__rreeppllyy(),               │               │         │
       │xxddrr__rreeppllyymmssgg(),                     │               │         │
       │xxpprrtt__rreeggiisstteerr(), xxpprrtt__uunnrreeggiisstteerr()  │               │         │
       └────────────────────────────────────┴───────────────┴─────────┘
SSEEEE AALLSSOO
       xxddrr(3)

       The following manuals:
              Remote Procedure Calls: Protocol Specification
              Remote Procedure Call Programming Guide
              rpcgen Programming Guide

       _R_P_C_: _R_e_m_o_t_e _P_r_o_c_e_d_u_r_e _C_a_l_l _P_r_o_t_o_c_o_l _S_p_e_c_i_f_i_c_a_t_i_o_n,  RFC 1050,  Sun  Mi‐
       crosystems, Inc., USC-ISI.

CCOOLLOOPPHHOONN
       This  page  is  part of release 5.10 of the Linux _m_a_n_-_p_a_g_e_s project.  A
       description of the project, information about reporting bugs,  and  the
       latest     version     of     this    page,    can    be    found    at
       https://www.kernel.org/doc/man-pages/.

                                  2020-11-01                            RPC(3)
