#ifndef SITE_CA_task_H
#define SITE_CA_task_H

#include "obj_ref.h"
#include "buffer2.h"
#include "SSL_stubs.h"
#include "SSL_CA1_stubs.h"

#include "X509_util_NAME.h"
#include "X509_util_EXT.h"
#include "SITE_X509_layout.h"

namespace CA1 {

/*!
	A SITE_CA_task is an instance of a CA creating a client X509
	(which might also be a CA), in a site specific manner,
	and using a REQ/ISS algorithm.

	Other sites might split the REQ/ISS halves,
	and there is a join line where that can be done.

	The VALS_xxx prefix, is for the values that go _INTO_ the REQ
	(my preferred form of REQ).

	You have some choice (confusion) about the subclasses

		MYSITE_CA_task
		MYSITE_layout

	Which one should specify that RSA keys are 1024 bits,
	except for CA_ZERO which is 2048. You decide ...

	There is an additional multiplier, load parameters from file,
	which can very per-host, per dir, per partname, per parent selector
	(there is no parent selector, other than parent_CA_tag, but could be)

	The idea was that a layout, would be fairly fixed, for a site,
	then different places within the site, would use different parameters,
	and values that go into VALS, loaded from ./settings/keys/CA_item/.ini

	loaded from ./settings/keys/%s=CA_item/.ini -> dir_expr argv into_CERT

	 FURNITURE INSTRUMENTS

	  SPECIFICALLY NAMED # EVAL SCRIPT ARGV # SCRIPT = ROM.SEGMENT.ITEM.EA

	    CA_ZERO
	    CA_%s
	     CA_ZERO
	     CA_ONE
	     CA_ZONE
	     C_ITEM
	     C_%s
	      C_ITEM
	      C_PERSON
	      C_LINK
	      C_CERT _of_SOMETHING _of_ID of_%s C_%s.id.cert C_PRINTER _eg_USER_ID
	      C_ID : public C_CERT += CN_CLAIM // DECODE(cn) // PC_101 //
	      += CN_SUBLEX_PARSER // common name = "PC_%4d" // "PC_%4X" // FF.H
	      C_UDEF : public C_ID 

	 CONVERSATION = LOGIN

	  var CA_POOL // DB_of_CA_ZONE // HERE == CA_ZONE // NAME == PURPOSE

		var CA_DB // VFS_PEM_FILES // X509_PRINTER // nib_draw_MMAP_ZONE
	  	var CA_SITE // The SITE runs it's local CA DB
		var C_SIGNED_LOCNS _DB C_FILTER_CRYPTS
		var C_SIGNED_C += data_or_code_or_both
		var C_ID_SUBSCRIBER // only USER knows RSA.priv_key 
		var C_ID_SERVICE // DB adds WELL_KNOWN_SERVICE // HTTP += HTTPS
		var C_ID_VLAN_ITEM
		var RSA_of_ 
		var _%s RSA_of_%s RSA_of_ID_%s // MULTIPLE in DB LOCN ATTR VAL
	
	 var KEY_POOL // KEY_TYPE==RSA_2048 // .priv // .rsa //

	 	var USER
		var SITE
		var PASS // C_%s PROOF PASS of %s // NAME = $NAME_OF_PERMIT
		var HELD // PROOF of possession of u8 SECRET_KEY[u8] //
		// HELD 256_bytes // PARSE %d_%s part alias "4K_bytes" "2048_bit"
		// rsa_key_2048 // 4096 2048 1024 512 256 128 64 bits
		// key_data nbytes == "u64_key" // u64_u64_t pair; // u128
		// link_key_

		var FILTER_2_KEY_1 // = FILTER_2.KEY_1
		var FILTER_2_KEY_2 // { 1 HELD 2 CLAIM } // { CLAIM_USE }

		var_expr FILTER_ITEM_KEY = { FILTER == CRYPT_LINE LINE == API }
		var API_key_pub = must_match(%s) // OPTION MATCH_by_NAME %s

		var HELD_key_priv == u64_random_secret // GEN_u64_KEY = rand_64

		var var_FILTER HELD {
			HELD u64 // other KEY_SIZE available 4096 2048 1024 
			u64 DATA_BEFORE
			u64 DATA_AFTER
			-CODE-
			u64 RET VAL = DATA_AFTER
			-CODE-
			u64 VAL = SCRIPT DATA_BEFORE // SCRIPT == {
			 u64 RET_VAL // init_zero
			 u64 IV = { SCRIPT } // install SET_VAR
			 KNOW "SET_VAR += DIALECTS" // VAR_POOL = lookup %s
			 KNOW " FN { RET_VAL = X_CRYPT { METHOD AES_4096_BYTE }}"
			 KNOW " METHOD AES _ENC _DEC _FILTER nbits == %d (4096)"
			 KNOW " API_fn = RUN_FILTER_OVER_1_WORD "
			 HAVE DECODE(WORD_PAIR) DECODE( DECRYPT ) 
			 HAD DECRYPT =from= WORD_PAIR
			}
		}

		VAR  TASK_with_DB_CERT
		VAR  CA_TASK { " PERMIT_CHECK_DATA " } // ITEM = EA_EXPR += ARGS
		
	CA_TASK is an example of a few items and their API

		C_DECODER VALS TAGS MINI_MACHINE with VAR{ VALS } VAR{ NAMES }
		C_PERMIT is_a_HELD { SECRET == AES_64 } // AES_256_bit

		use DECODER to explain all corners of X509
		use PERMIT if CERT_lhs == CERT_rhs // ROM MATCH PERMIT_api //
	
	PERMIT_API

		EXACT_MATCH SECRET { ACTION }

		cached_value bool _PLUS # bool OK = EXACT_MATCH_YES lhs == rhs

		bool cached_bool = TEST EXACT_MATCH u64 lhs rhs

		EXPR IMPORT { a_few_items } SCRIPT { 
			PERMITTED ACTION HERE
			FILTER was applied over this SCRIPT
			SCRIPT is itself generated by SCRIPT_WRITER
			ie PERMIT allows SCRIPT to exist and be RUN
			or PERMIT allows DATA ... yada yada ...
		}

		CALL ENCODE_WORD_PAIR
		 ENCODE { void * func( args ) } WORD_PAIR
		 STEP ENCODE WORD_PAIR (argc argv)
		 STEP ENCODE WORD_PAIR (u48_u16_u64 STEP)

		So that is the ACTIVITY that is PROTECTED by PERMIT
		ACTIVITY == "FLOW_DECRYPT_individual_u64_WORDS" // REPEAT NBYTES

		ACTIVITY == "PICK DECODE RANDOM WORD to get SPECIFIC_known_val"

		ACTIVITY == "DECODE_WORD_PAIR" u64[2]
		ACTIVITY == "DECODE_WORD_PAIR_FILE" u8[u24] // 16MB then 4G
		ACTIVITY == "DECODE ENCODE FILTER"
		// default DECODE = FILTER = DECODE BF64

		BF64 is blowfish with a 64 bit key size // tad low

			used for mild permits, user_id, MINI_MACHINE_PC,

		DD512 is 4096_bits %s_%s 512_bytes

			SATA drive block size 512_bytes
			SATA drive block size 4K_bytes

			KEY == SECRET
			decoded_bytes[u12] // 4K_PAGE
			encoded_byes[u12] // possible unreachable // pre DONE

		MMAP DEVICE

			decrypt pages into 4K on MMAP demand
			write back encrypted // cache queue 

			This is not invincible, as /proc/mem is debuggable
			But a very fast 64_bit XOR CRYPT_FILTER _PAIR run over

			That gives a MMAP DB with encrypted pages, fast API ROM
			LINK MMAP_DB_PAGE_DECRYPTER ==--> FILTER

			MMAP MANIFEST 4096_bytes _of_ PAGE[idx_page] // ZONE

			The DEVICE logs ALL WRITE_PAGE_BACK "u8 4096_bytes[4096]""
			SO API FLUSH for COMPILER does a sensible SYNC
			GOTO version of file HERE

		MACRO ENCODE	FILTER --encode
		MACRO DECODE	FILTER --decode
		SCRIPT FILTER	{ SCRIPT DATA }
		FILTER needs to hold_key SECRET("FILTER.KEY.priv")
		FILTER ALSO needs hold_key SECRET("FILTER.KEY.priv")
		FILTER ALSO needs hold_key IV=OFFS // agreed world PAGE0

		CA_TASK += login_TASK += sign_WORDS += claim_x509_from_SECRET

		CA_TASK FILTER
			decode 4K from KEY IV CODE PAGE {
			_encoded (in)
			_decoded(out)
			}
 CA_TASK
 TASKS += TASKS_X509_and_TREE // TRUST document as SIGNED OK_TO_RUN
 TASKS += login_with_X11_run_SESSION // scripts wrap calling this
 TASKS += 

 MATCH CODE ACTION INTERPRET

 	PERMIT += PROOF_of_knowing_ SECRET
	PERMIT += PERMITS access to item (access += mode)
	PERMIT += ENABLES decrypt that uses SECRET // it knows we dont // we know
	PERMITS "login as { user_name %s } { user_id %d } // NEEDS SECRET"
	DUAL PORT concept is AS_EXISTS the secure mode splits and OMITS JUMPS DONE
	PERMITS "access mode to item VFS item"
	PERMITS "permit_read _read _write _exec _delete _use _create _PERMIT"

	PERMITS "premit_EVAL" == "premit_READ" // QUOTAS += local_QUOTAS

 LOGIC DIALECT

 	match "MATCH keyword" "4096_bytes" join "%s_%s" match join match expr

	MATCH
	JOIN lhs rhs 
	STRUCT fields
	ITEM WRAP LINK MERGE JOIN ARRAY UNION DERIVE





*/
class CA_task : public obj_ref0
{
 public:

	obj_hold<SITE_X509_tag>		layout_tag;

	obj_hold<X509_VALS_base>	VALS;
	obj_hold<X509_REQ_hold>		REQ;
//	obj_hold<X509_util_CERT>	UTIL;
	X509_util_NAME			UTIL_subject;
	X509_util_EXT_list /*_req*/	UTIL_extensions;

	// these two can actually be the same thing
	// but only the CA can have the self_key loaded
	// the other would need a different self_
	// splitting them simply means copying them over

	obj_hold<MYSITE_loaded>		CA_site_loaded;
	obj_hold<MYSITE_loader>		CA_site_loader;
	obj_hold<MYSITE_loaded>		C_site_loaded;
	obj_hold<MYSITE_loader>		C_site_loader;

	/*
		NOW I want sparse-of-four load+save
	*/

	obj_hold<EVP_P_KEY>		client_key_pub;
	obj_hold<EVP_P_KEY>		client_key_priv;

	CA_task(
		SITE_X509_layout * scheme,
		SITE_X509_tag_enum _tag
	);
	~CA_task();
	bool clear();

	bool VALS_set_CA_depth_for_layout();
	bool VALS_check_C_not_CA();
	bool VALS_check_CA_not_C();

	bool VALS_set_HERE_part0(SITE_X509_tag_enum _tag);
 virtual
        bool VALS_set_HERE_part1_nbits_RSA();
 virtual
        bool VALS_set_HERE_part1_subject();
 virtual
        bool VALS_set_HERE_part1_time_range();

        bool REQ_set_client_key_priv( EVP_P_KEY * key );
        bool REQ_create_client_key_priv();
 virtual
	bool obtain_client_cb_phrase(); // SITE_


//	The CA_task gets the _layout to do these things (called at right time)
//	prefix with SITE_ ???


	virtual bool obtain_issuer_certificate_and_key(); // ISS
	virtual bool obtain_issuer_cb_phrase();

	virtual bool make_file_names();
	virtual bool ISS_write_client_cert_and_key(); // _to_files!

	bool clear_issuer_cert_and_key();
	bool clear_client_cert_and_key();

	bool REQ_apply_VALS();
	bool REQ_apply_VALS( X509_VALS_base & vals );
	bool REQ_sign_with_client_key_priv();

	//////////////////////////

//	virtual bool ISS_make_file_names();	// similar when SQL keyname not filename

//	virtual bool ISS_obtain_issuer_cb_phrase();
//	virtual bool ISS_obtain_issuer_certificate_and_key();

	bool REQ_mk_cert_from_VALS();
	bool ISS_mk_cert(); // from REQ and a few VALS and issuer* etc

	bool ISS_new_cert_version_2();
	bool ISS_copy_REQ_subject_name();
	bool ISS_copy_REQ_subject_alt_name(); // but is extension
	bool ISS_copy_REQ_client_key_public(); // from REQ
	bool ISS_get_client_key_public_FROM_REQ();
	bool ISS_put_client_key_public_INTO_CERT();
	bool ISS_copy_REQ_all_extensions(); // from REQ
	bool ISS_copy_CA_issuer_name(); // from issuer_cert
	bool ISS_copy_CA_issuer_hash(); // from issuer_cert

	bool ISS_copy_VALS_serial();
	bool ISS_copy_VALS_time_range();
	bool ISS_put_serial( int ser );
	bool ISS_put_time_range( X509_VALS_time_range & time_range );

	bool ISS_sign_with_CA_priv();

 /////////////////// EXISTS BUT DOES NOT EXIST ///////// NOT REFERED TO

//	bool ISS_write_to_files( const char * cert_filename, const char *key_filename );

};
}; // NS
#endif

